/* File generated by the BNF Converter (bnfc 2.9.4). */

#ifndef __JLC_LLVM_GENERATOR__
#define __JLC_LLVM_GENERATOR__
/* You might want to change the above name. */
#include <iostream>

#include "Absyn.H"
#include "context.H"

#include "Skeleton.H"


// llvm dependencies
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Value.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Type.h"



class JLCLLVMGenerator : public Skeleton
{
public:
  Context globalContext;
  type_enum temp_type;
  op_enum temp_op;

  JLCLLVMGenerator(): LLVM_Context_(std::make_unique<llvm::LLVMContext>()),
                      LLVM_module_(std::make_unique<llvm::Module>("JLC_llvm", *LLVM_Context_)),
                      LLVM_builder_(std::make_unique<llvm::IRBuilder<>>(*LLVM_Context_))
  {
    addExternalFunc();
  };

  ~JLCLLVMGenerator(){
    LLVM_module_->print(llvm::outs(), nullptr);
  };
  

private:
  /* serving for generating llvm code*/
  std::unique_ptr<llvm::LLVMContext> LLVM_Context_;
  std::unique_ptr<llvm::Module> LLVM_module_;
  std::unique_ptr<llvm::IRBuilder<>> LLVM_builder_;

  llvm::Value * llvm_temp_value_;
  std::string x86_temp_value;

  // GET _CONTEXT()
  llvm::LLVMContext &GET_CONTEXT(){
    return *LLVM_Context_;
  }
  
  // for saving the block of the value
  // @TODO: there are should be a better way to do this
  std::map<std::string,llvm::BasicBlock *> value_block_map_; 

  void setLLVMTempValue(llvm::Value * value){
    llvm_temp_value_ = value;
    // add the block of the value to the map
    value_block_map_[std::string(value->getName())] = LLVM_builder_->GetInsertBlock();
  }

  llvm::BasicBlock * getBlockOfValue(llvm::Value* &value){
    if (value_block_map_.find(std::string(value->getName())) != value_block_map_.end()){
      return value_block_map_[std::string(value->getName())];
    }
    // should not reach here
    std::cerr << "Error: block of value not found" << std::endl;
    exit(1);
    return nullptr;
  }

  // for saving the variable in the block, the last element is the current block
  // mapping from original variable name to llvm variable 
  std::vector<std::map<std::string, llvm::Value *>> block_var_map_list;

  void addBlockVarMap(){
    block_var_map_list.push_back(std::map<std::string, llvm::Value *>());
  }

  void removeBlockVarMap(){
    block_var_map_list.pop_back();
  }

  void addVarToBlockMap(std::string var_name, llvm::Value * var_value){
    block_var_map_list.back()[var_name] = var_value;
  }

  llvm::Value * getVarFromBlockMap(std::string var_name){
    for (int i = block_var_map_list.size() - 1; i >= 0; i--){
      if (block_var_map_list[i].find(var_name) != block_var_map_list[i].end()){
        return block_var_map_list[i][var_name];
      }
    }
    // it should not reach here
    std::cerr << "Error: variable " << var_name << " not found in llvm block name map" << std::endl;
    return nullptr;
  }


  // write some functions to simulate the x86 stack. mapping stack location to variable name and value.
  //  each stack correspond a local block(function). when a new block is created, a new stack is created.
  // for using of function call. each time a int/float is pushed to the stack, the stack pointer will be increased by 4/8
  // for example, two init variables, a and b, a is int, b is double, then the stack will be like this:
  // [rbp-4]: a, 1
  // [rbp-(4+8)]: b, 2.0
  // record the stack top pointer
  // for saving the stack of the block
  std::vector<std::map<int, std::pair<std::string, llvm::Value *>>> block_stack_map_list;

  void addBlockStackMap(){
    block_stack_map_list.push_back(std::map<int, std::pair<std::string, llvm::Value *>>());
  }

  void removeBlockStackMap(){
    block_stack_map_list.pop_back();
  } 


  void addVarToStackMap(std::string var_name, llvm::Value * var_value){
    int stack_top = 0;
    if (block_stack_map_list.back().size() > 0){
      stack_top = block_stack_map_list.back().rbegin()->first;
    }
    //if type is int, then stack_top - 4, if type is double, then stack_top - 8
    int stack_offset = 4;
    if (var_value->getType()->isDoubleTy()){
      stack_offset = 8;
    }
    block_stack_map_list.back()[stack_top - stack_offset] = std::make_pair(var_name, var_value);
  }

  llvm::Value * getVarFromStackMap(std::string var_name){
    for (int i = block_stack_map_list.size() - 1; i >= 0; i--){
      for (auto it = block_stack_map_list[i].begin(); it != block_stack_map_list[i].end(); it++){
        if (it->second.first == var_name){
          return it->second.second;
        }
      }
    }
    // it should not reach here
    std::cerr << "Error: variable " << var_name << " not found in llvm block stack map" << std::endl;
    return nullptr;
  }

  // get the stack top pointer
  int getStackTop(){
    if (block_stack_map_list.back().size() > 0){
      return block_stack_map_list.back().rbegin()->first;
    }
    return 0;
  }

  //get the stack location of the variable through value*
  int getStackLocation(llvm::Value * value){
    for (auto it = block_stack_map_list.back().begin(); it != block_stack_map_list.back().end(); it++){
      if (it->second.second == value){
        return it->first;
      }
    }
    // it should not reach here
    std::cerr << "Error: value not found in llvm block stack map" << std::endl;
    return -1;
  }






  // type conversion
  llvm::Type *convertType(type_enum type);
  // add inner/external function to the head of the ll file
  // for example, printInt, printDouble, printString, printBool
  void addExternalFunc();

  void addFuncDeclearation(Frame &frame);

  

public:
  // void visitProg(Prog *p);
  // void visitTopDef(TopDef *p);
  // void visitArg(Arg *p);
  // void visitBlk(Blk *p);
  // void visitStmt(Stmt *p);
  // void visitItem(Item *p);
  // void visitType(Type *p);
  // void visitExpr(Expr *p);
  // void visitAddOp(AddOp *p);
  // void visitMulOp(MulOp *p);
  // void visitRelOp(RelOp *p);
  
  void visitProgram(Program *p);
  void visitFnDef(FnDef *p);
  void visitArgument(Argument *p);
  void visitBlock(Block *p);
  void visitEmpty(Empty *p);
  void visitBStmt(BStmt *p);
  void visitDecl(Decl *p);
  void visitNoInit(NoInit *p);
  void visitInit(Init *p);
  void visitInitElem(InitElem *p);
  void visitAss(Ass *p);
  void visitArrayAss(ArrayAss *p);
  void visitIncr(Incr *p);
  void visitDecr(Decr *p);
  void visitRet(Ret *p);
  void visitVRet(VRet *p);
  void visitCond(Cond *p);
  void visitCondElse(CondElse *p);
  void visitForBlk(ForBlk *p);
  void visitForLoop(ForLoop *p);
  void visitWhile(While *p);
  void visitSExp(SExp *p);
  void visitInt(Int *p);
  void visitDoub(Doub *p);
  void visitBool(Bool *p);
  void visitVoid(Void *p);
  void visitIntArray(IntArray *p);
  void visitDoubArray(DoubArray *p);
  void visitBoolArray(BoolArray *p);
  void visitFun(Fun *p);
  void visitEVar(EVar *p);
  void visitEArrayLen(EArrayLen *p);
  void visitEArrayNew(EArrayNew *p);
  void visitEArray(EArray *p);
  void visitELitInt(ELitInt *p);
  void visitELitDoub(ELitDoub *p);
  void visitELitTrue(ELitTrue *p);
  void visitELitFalse(ELitFalse *p);
  void visitEApp(EApp *p);
  void visitEString(EString *p);
  void visitNeg(Neg *p);
  void visitNot(Not *p);
  void visitEMul(EMul *p);
  void visitEAdd(EAdd *p);
  void visitERel(ERel *p);
  void visitEAnd(EAnd *p);
  void visitEOr(EOr *p);
  void visitPlus(Plus *p);
  void visitMinus(Minus *p);
  void visitTimes(Times *p);
  void visitDiv(Div *p);
  void visitMod(Mod *p);
  void visitLTH(LTH *p);
  void visitLE(LE *p);
  void visitGTH(GTH *p);
  void visitGE(GE *p);
  void visitEQU(EQU *p);
  void visitNE(NE *p);
  // void visitListTopDef(ListTopDef *p);
  // void visitListArg(ListArg *p);
  // void visitListStmt(ListStmt *p);
  // void visitListItem(ListItem *p);
  // void visitListType(ListType *p);
  // void visitListExpr(ListExpr *p);

  // void visitInteger(Integer x);
  // void visitChar(Char x);
  // void visitDouble(Double x);
  // void visitString(String x);
  // void visitIdent(Ident x);
  // void x86CodeGen(auto F);

};


#endif
