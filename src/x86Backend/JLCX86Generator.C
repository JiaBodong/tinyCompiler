/* File generated by the BNF Converter (bnfc 2.9.4). */

/*** Visitor Design Pattern JLCX86Generator. ***/
/* This implements the common visitor design pattern.
   Note that this method uses Visitor-traversal of lists, so
   List->accept() does NOT traverse the list. This allows different
   algorithms to use context information differently. */

#include "JLCX86Generator.H"
#include "util.h"
#include "Printer.H"

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <cstdlib>
#include "llvm/Support/raw_ostream.h"

static PrintAbsyn p = PrintAbsyn();

static const std::string GeneratorName = "JLCX86Generator";
std::ofstream outfile("x86output.s");

std::string FPRecord="";
std::string BStmtBlkLabel ="";
std::string BStmtBlkEndLabel ="";
std::string BStmtBlkEndEndLabel ="";
std::string FinalEndLabel =".LB0";//for final return


std::string BoolBlkLabel = "";//for eor bool label
std::string BoolBlkEndLabel = "";//for eor bool label
std::string BoolBlkEndEndLabel = "";//for eor bool label


int FPCounter=0;
int CondCounter=0;
int NoBstmt = -2;

int StrCounter = 0;
std::string StrRecord = "";

int isBstmt = 0;//for sexp in condblk

bool hasCond = false; //for recording a main blk if has cond

int ASTcounter = 0;


#define ERRPR_HANDLE(msg) \
  while(1){ \
  std::cerr << "Error: " << msg << std::endl; \
  LLVM_module_->print(llvm::outs(), nullptr); \
  exit(1);\
  }

/*
  this function is used to convert the type_enum to string
  @return: llvm::Type*
  @param: type_enum t
*/
llvm::Type* JLCX86Generator::convertType(type_enum t){
  switch (t)
  {
  case INT:
    return llvm::Type::getInt32Ty(*LLVM_Context_);
  case DOUB:
    return llvm::Type::getDoubleTy(*LLVM_Context_);
  case BOOL:
    return llvm::Type::getInt1Ty(*LLVM_Context_);
  case VOID:
    return llvm::Type::getVoidTy(*LLVM_Context_);
  case CHAR:
    return llvm::Type::getInt8Ty(*LLVM_Context_);
  case STRING: // the atcually out is ptr not i8*, is it ok? @todo
    return llvm::Type::getInt8PtrTy(*LLVM_Context_);
  default:
    std::cerr << "Error, Unknown type:" << to_string(t) << std::endl;
    exit(1);
  }
}

std::string JLCX86Generator::spillRegister(std::string TEMP_REG,type_enum TEMP_TYPE){
      updateRegisterAvailability(TEMP_REG, false);
      std::stringstream ss;
      addVarToStackMap("", nullptr);
      if(TEMP_TYPE == INT){
        ss << "  mov " << "dword [rbp" << getStackTop() << "], " << TEMP_REG << std::endl;
        auto reg = TEMP_REG;
        TEMP_REG = checkIntRegisterAvailability();
        updateRegisterAvailability(reg, true);
        ss << "  mov " << TEMP_REG << ", " << "dword [rbp" << getStackTop() << "]";
        updateRegisterAvailability(TEMP_REG, false);
      }else if(TEMP_TYPE == DOUB){
        ss << "  movss " << "dword [rbp" << getStackTop() << "], " << TEMP_REG<< std::endl;
        auto reg = TEMP_REG;
        TEMP_REG = checkDoubleRegisterAvailability();
        updateRegisterAvailability(reg, true);
        ss << "  movss " << TEMP_REG << ", " << "dword [rbp" << getStackTop() << "]";
        updateRegisterAvailability(TEMP_REG, false);
      } else if(TEMP_TYPE == BOOL){
        ss << "  mov " << "dword [rbp" << getStackTop() << "], " << TEMP_REG << std::endl;
        auto reg = TEMP_REG;
        TEMP_REG = checkIntRegisterAvailability();
        updateRegisterAvailability(reg, true);
        ss << "  mov " << TEMP_REG << ", " << "dword [rbp" << getStackTop() << "]";
        updateRegisterAvailability(TEMP_REG, false);
      }
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
      return TEMP_REG;
}


void updateBoolBlk(){
  CondCounter++;
  BoolBlkLabel = ".LB"+std::to_string(CondCounter);//for eor bool label
  CondCounter++;
  BoolBlkEndLabel = ".LB"+std::to_string(CondCounter);//for eor bool label
  CondCounter++;
  BoolBlkEndEndLabel = ".LB"+std::to_string(CondCounter);//for eor bool label
}


void JLCX86Generator::addExternalFunc(){
  for (auto & func : globalContext.funcs)
  {
    addFuncDeclearation(func.second);
  }  
}

void JLCX86Generator::addFuncDeclearation(Frame &frame){
  // see the tutorial about llvm: 
  std::string func_name = frame.name;
  auto llvm_return_type = convertType(frame.returnType);
  std::vector<llvm::Type*> llvm_args;
  for (auto & arg : frame.args)
  {
    llvm_args.push_back(convertType(arg.second));
  }
  llvm::FunctionType* func_type = 
    llvm::FunctionType::get(llvm_return_type, llvm_args, false);
  auto func_dec = llvm::Function::Create(
      func_type, 
      llvm::Function::ExternalLinkage, 
      func_name, 
      LLVM_module_.get());
  
  globalContext.addFrame(func_name);

  std::string ss;
  llvm::raw_string_ostream ss2(ss);
  func_dec->print(ss2);
  DEBUG_PRINT("Add function declearation: " + ss);
}



void JLCX86Generator::visitProgram(Program *program)
{
  /* Code For Program Goes Here */
  /* iterate through the top definitions */
  // this part is same as the type checker, will add all the functions to the context
  restoreFunctionArgQueue();

  for (ListTopDef::iterator top_def = program->listtopdef_->begin() ; top_def != program->listtopdef_->end() ; ++top_def)
  {
    FnDef* fn_def = reinterpret_cast<FnDef*>(*top_def);
    visitIdent(fn_def->ident_);
    // add the function to the global context
    globalContext.addFrame(fn_def->ident_);
    globalContext.currentFrameName = fn_def->ident_;

    // update the function return type
    Frame& func = globalContext.getFrame(fn_def->ident_);
    fn_def->type_->accept(this);
    func.returnType = temp_type;

    // check function arguments
    if (fn_def->listarg_) fn_def->listarg_->accept(this);

    // add to llvm module - start
    // @todo maybe we can drop the self-defined CONTEXT, 
    // and use the llvm::Module directly

    auto llvm_return_type = convertType(func.returnType);
    std::vector<llvm::Type*> llvm_args;
    for (auto & arg : func.args)
    {
      llvm_args.push_back(convertType(arg.second));
    }
    llvm::FunctionType* func_type = 
      llvm::FunctionType::get(llvm_return_type, llvm_args, false);
    auto local_llvm_func = llvm::Function::Create(
        func_type, 
        llvm::Function::ExternalLinkage, 
        func.name, 
        LLVM_module_.get());
    
    // set arguments name
    auto arg_iter = local_llvm_func->arg_begin();
    for (size_t i = 0; i < func.args.size(); i++)
    {
      arg_iter->setName(func.args[i].first);

      arg_iter++;
    }
    // add to llvm module - end 
    // debug print
    std::string ss;
    llvm::raw_string_ostream ss2(ss);
    local_llvm_func->print(ss2);
    DEBUG_PRINT("Add function define: " + ss);
  }

  if (program->listtopdef_) program->listtopdef_->accept(this);

  //before finish the program,  insert some code to the head of outfile
  insertContentAtBeginning("x86output.s", "extern printInt\nextern printDouble\nextern printString\nextern readInt\nextern readDouble\nsection .data\n negmask dd 0x80000000\n epsilon dd 0.0000001\n"+FPRecord+StrRecord+"section .text\nglobal main");


}

void JLCX86Generator::visitFnDef(FnDef *fn_def)
{
  /* Code For FnDef Goes Here */
  globalContext.currentFrameName = fn_def->ident_; // set context to the current function


  // reset inner variables before visiting the function body
  block_var_map_list.clear();

  // create a new block 
  DEBUG_PRINT("Create the entry block")
  auto & func = globalContext.currentFrame();
  func.newBlock();
  addBlockVarMap();
  addBlockStackMap();
  addBlockVarInfoMap (); // this is used to store the arguments
  // add a new block to the function
  auto llvm_func = LLVM_module_->getFunction(func.name);
  llvm::BasicBlock* entry = 
    llvm::BasicBlock::Create(*LLVM_Context_, "entry", llvm_func);
  LLVM_builder_->SetInsertPoint(entry);
  

  DEBUG_PRINT("init args");
 
  // if the block is the function body, we need to add the arguments to the block
  if (func.blk->parent == nullptr)
  {

    for (auto & arg : func.args)
    {
      //auto arg_iter = llvm_func->arg_begin();// get the value* of the argument
      for (size_t i = 0; i < func.args.size(); i++)
      {
        // if (arg.first == std::string(arg_iter->getName()))
        // {  
          //auto alloca = LLVM_builder_->CreateAlloca(convertType(arg.second), nullptr, arg.first);
          //LLVM_builder_->CreateStore(arg_iter, alloca);
          addVarToBlockMap(arg.first, nullptr);
            // set x86 information
          addVarToStackMap(arg.first, nullptr);
          int stkptr = getStackTop();
          
          addVarInfoToBlockMap(arg.first, nullptr, stkptr,"");
          
          auto reg = popArgFromFunctionMap(arg.second);
          if(reg==""){
            //push the inst to x86_code_inst
            std::stringstream ss;
            if(arg.second == DOUB){
              reg = checkDoubleRegisterAvailability();
              auto loc = register_spill_location.front();
              register_spill_location.erase(register_spill_location.begin());
              ss << "  movss " << reg << ", dword [rbp+" << loc << "]";
            } else if(arg.second == INT){
              reg = checkIntRegisterAvailability();
              auto loc = register_spill_location.front();
              register_spill_location.erase(register_spill_location.begin());
              ss << "  mov " << reg << ", dword [rbp+" << loc << "]";
            } 
            std::string inst = ss.str();
            x86_function_map[globalContext.currentFrameName].push_back(inst);
          }
          
          //push the inst to x86_code_inst
          std::stringstream ss;
          if(arg.second == DOUB){
            ss << "  movss dword [rbp" << stkptr << "], "<< reg;
          } else if(arg.second == INT){
            ss << "  mov dword [rbp" << stkptr << "], "<< reg;
          } else if(arg.second == BOOL){
            ss << "  mov dword [rbp" << stkptr << "], "<< reg;
          }
          std::string inst = ss.str();
          x86_function_map[globalContext.currentFrameName].push_back(inst);
          //restore the register availability
          updateRegisterAvailability(reg, true);
          break;
        //}
        //arg_iter++;
      }
    }
      // after init args to stack, restore the function arg map
    restoreFunctionArgQueue();
  }


  // cotinue to iterate the function body
  if (fn_def->blk_) fn_def->blk_->accept(this);

  if(hasCond==true&&NoBstmt==-2){

    std::stringstream ss;
    ss<<FinalEndLabel<<":\n  leave\n  ret";
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }

  hasCond = false;//update, for the next function
  

  if(function_call_map[globalContext.currentFrameName]==true){
    int blktop = getStackTop();

    std::stringstream ss;
   
    if(!register_spill_location.empty()){
      setTempStackSize();
      ss<< ((-blktop+(register_spill_location.size()-1)*4)/16+1)*16 ;
      std::string sub_rsp_value = ss.str();
      x86_function_map[globalContext.currentFrameName].insert(x86_function_map[globalContext.currentFrameName].begin(),"  sub rsp, "+sub_rsp_value);
    }else{
      ss << ((-blktop)/16+1)*16;
      std::string sub_rsp_value = ss.str();
      x86_function_map[globalContext.currentFrameName].insert(x86_function_map[globalContext.currentFrameName].begin(),"  sub rsp, "+sub_rsp_value);
    }
  }


  // store the x86 code to the x86_code_vector
  x86_function_map[globalContext.currentFrameName].insert(x86_function_map[globalContext.currentFrameName].begin(),"  mov rbp, rsp");
  x86_function_map[globalContext.currentFrameName].insert(x86_function_map[globalContext.currentFrameName].begin(),"  push rbp");
  x86_function_map[globalContext.currentFrameName].insert(x86_function_map[globalContext.currentFrameName].begin(),globalContext.currentFrameName + ":");
  

  // check if the predecessor block is terminated
  if (LLVM_builder_->GetInsertBlock()->getTerminator() == nullptr)
  {
    // if the block is not terminated, we need to add a return statement
    if (func.returnType == VOID)
    {
      //LLVM_builder_->CreateRetVoid();
      x86_function_map[globalContext.currentFrameName].push_back("  nop");
      x86_function_map[globalContext.currentFrameName].push_back("  leave");
      x86_function_map[globalContext.currentFrameName].push_back("  ret");
    }
    else
    {
     ERRPR_HANDLE("function block does not have a return statement");
    }
  }

    // print x86 code to the asm file

    for(const auto & ins : x86_function_map[globalContext.currentFrameName]){
      outfile << ins << std::endl;
    }
  
  

  // release the block
  DEBUG_PRINT("release the entry block");
  func.releaseBlock();
  removeBlockVarMap();
  removeBlockStackMap();
  removeBlockVarInfoMap();
}

void JLCX86Generator::visitArgument(Argument *argument)
{
  /* Code For Argument Goes Here */
  // this part is same as the type checker,
  // will add all the arguments to the function
  // but does not check the types of the arguments in generator
    if (argument->type_) argument->type_->accept(this);
    DEBUG_PRINT("\tArgument name: " + argument->ident_ + 
      "\tArgument type: " + to_string(temp_type));
    Frame& func = globalContext.getFrame(globalContext.currentFrameName);
    // add the argument to the function
    func.addArg(argument->ident_, temp_type);
}

void JLCX86Generator::visitBlock(Block *block)
{
  /* Code For Block Goes Here */
  DEBUG_PRINT( "[" + GeneratorName  +"]" + " visiting Block");
  DEBUG_PRINT("go through the block")
  
  if (block->liststmt_) block->liststmt_->accept(this);
  
  if(NoBstmt==1&&condHasReturn==false){
    std::stringstream ss;
    ss<<"  jmp "<<BStmtBlkEndEndLabel;
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }else if(NoBstmt==-1){
    ;
  }else if(hasCond&&NoBstmt==-2){

    // std::stringstream ss;
    // ss<<FinalEndLabel<<":\n  leave\n  ret";
    // x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }
  //hasCond = false;
}

void JLCX86Generator::visitEmpty(Empty *empty)
{
  /* Code For Empty Goes Here */
  //x86 assembly generator for empty
  //std::cout << "  nop" << std::endl;
  x86_function_map[globalContext.currentFrameName].push_back("  nop");
}

void JLCX86Generator::visitBStmt(BStmt *b_stmt)
{
  /* Code For BStmt Goes Here */
  isBstmt = 1;
  std::stringstream ss;
  if(NoBstmt==0){
    ss<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }else if(NoBstmt==1){
    ss<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }else if(NoBstmt==2){
    ss<<BStmtBlkEndLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }else if(NoBstmt==-1){
    ;
  } else if(NoBstmt==-2){
    ;
  }

  DEBUG_PRINT( "[" + GeneratorName  +"]" + " visiting BStmt");
  auto & func = globalContext.currentFrame();
  func.newBlock();
  addBlockVarMap(); // this 
  addBlockVarInfoMap();
  if (b_stmt->blk_) b_stmt->blk_->accept(this);
  


  // release the block
  DEBUG_PRINT("release block");
  func.releaseBlock();
  removeBlockVarMap();
  removeBlockVarInfoMap();
  isBstmt = 0;
}

void JLCX86Generator::visitDecl(Decl *decl)
{
  /* Code For Decl Goes Here */
  if (decl->type_) decl->type_->accept(this);
  auto temp_decl_type = temp_type;
  for (auto & item : *(decl->listitem_)){
    temp_type = temp_decl_type; // !! this is important, as the type will pase to the next level
    item->accept(this);
  }
 

}

void JLCX86Generator::visitAss(Ass *ass)
{
  /* Code For Ass Goes Here */

  visitIdent(ass->ident_);
  if (ass->expr_) ass->expr_->accept(this);
  // llvm_temp_value_ is set by next level (accept)
  auto var = getVarFromBlockMap(ass->ident_);

  LLVM_builder_->CreateStore(llvm_temp_value_, var);
  
  auto varInfo = getVarInfoFromBlockMap(ass->ident_);

  //change the Value* of varInfo
  varInfo->value = var;

  //get the stack location from varInfo
  auto stkptr = varInfo->stack_location;

  
  if(x86_temp_value_type == "Imm"){
    //std::cout << "  mov dword [rbp" << stkptr << "], " << x86_temp_value<< std::endl;
    // push the inst to x86_code_inst
    std::stringstream ss;
    if(temp_type==DOUB){
      ss << "  movss dword [rbp" << stkptr << "], " <<x86_temp_FPregister;
      updateRegisterAvailability(x86_temp_FPregister,true);
    }else if(temp_type==INT){
      ss << "  mov dword [rbp" << stkptr << "], " <<x86_temp_value;
    } else if(temp_type==BOOL){
      ss << "  mov byte [rbp" << stkptr << "], " <<x86_temp_value;
    }
  
    std::string inst = ss.str();
    x86_function_map[globalContext.currentFrameName].push_back(inst);

  }else{
    std::stringstream ss;
    if(temp_type==DOUB){
      ss << "  movss dword [rbp" << stkptr << "], " <<TEMP_REG;
      updateRegisterAvailability(TEMP_REG,true);
    }else if(temp_type==INT){
      ss << "  mov dword [rbp" << stkptr << "], " <<TEMP_REG;
      updateRegisterAvailability(TEMP_REG,true);
    }else if(temp_type==BOOL){
      ss << "  mov dword [rbp" << stkptr << "], " <<TEMP_REG;
      updateRegisterAvailability(TEMP_REG,true);
    }
    std::string inst = ss.str();
    x86_function_map[globalContext.currentFrameName].push_back(inst);
  }
  
}

void JLCX86Generator::visitArrayAss(ArrayAss *array_ass)
{
  /* Code For ArrayAss Goes Here */

  if (array_ass->expr_1) array_ass->expr_1->accept(this);
  if (array_ass->expr_2) array_ass->expr_2->accept(this);

}

void JLCX86Generator::visitIncr(Incr *incr)
{
  /* Code For Incr Goes Here */

  //visitIdent(incr->ident_);
  // x++ -> x=x+1
  auto var = getVarFromBlockMap(incr->ident_);
  // load x must but int type, it will be check by the typer checker
  auto load = LLVM_builder_->CreateLoad(
      convertType(INT), var, incr->ident_);
  // add with 1 
  auto op = LLVM_builder_->CreateAdd(
        load, 
        llvm::ConstantInt::get(*LLVM_Context_, 
            llvm::APInt(32, 1)),
        "add");
  // store
  LLVM_builder_->CreateStore(op, var);

  // x86 ++
  std::stringstream ss;
  
  auto stkloc = getStackLocation(incr->ident_);
  ss << "  mov eax, dword [rbp"<<stkloc<<"]\n";
  ss << "  add eax, "<<"1\n";
  ss << "  mov dword [rbp"<<stkloc<<"], eax";
  
  x86_function_map[globalContext.currentFrameName].push_back(ss.str());

}

void JLCX86Generator::visitDecr(Decr *decr)
{
  /* Code For Decr Goes Here */

  //visitIdent(decr->ident_);
  // x-- -> x=x-1
  auto var = getVarFromBlockMap(decr->ident_);
  // load x must but int type, it will be check by the typer checker
  auto load = LLVM_builder_->CreateLoad(
      convertType(INT), var, decr->ident_);
  // sub 1 
  auto op = LLVM_builder_->CreateSub(
        load, 
        llvm::ConstantInt::get(*LLVM_Context_, 
            llvm::APInt(32, 1)),
        "sub");
  // store
  LLVM_builder_->CreateStore(op, var);
  // store does not return a value, 
  // so we do not need to set llvm_temp_value_

  // x86 --
  std::stringstream ss;

  auto stkloc = getStackLocation(decr->ident_);
  ss << "  mov eax, dword [rbp"<<stkloc<<"]\n";
  ss << "  sub eax, "<<"1\n";
  ss << "  mov dword [rbp"<<stkloc<<"], eax";

  x86_function_map[globalContext.currentFrameName].push_back(ss.str());
}

void JLCX86Generator::visitRet(Ret *ret)
{
  /* Code For Ret Goes Here */
  DEBUG_PRINT("visitRet");
   std::stringstream ss;
  if(NoBstmt==0&&isBstmt==0){
    ss<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }else if(NoBstmt==1&&isBstmt==0){
    ss<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }else if(NoBstmt==2&&isBstmt==0){
    ss<<BStmtBlkEndLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }else if(NoBstmt==-1&&isBstmt==0){
    ;
  } else if(NoBstmt==-2&&isBstmt==0){
    ;
  }
  if (ret->expr_) ret->expr_->accept(this);
  // add llvm return 
  LLVM_builder_->CreateRet(llvm_temp_value_);


  //for x86 assembly generator
  if(x86_temp_value_type=="Imm"){
    if(temp_type == DOUB){

      x86_function_map[globalContext.currentFrameName].push_back("  movss xmm0, " + x86_temp_FPregister);
    } else if(temp_type == INT){

      x86_function_map[globalContext.currentFrameName].push_back("  mov eax, " + x86_temp_value);
    } else if(temp_type == BOOL){

      x86_function_map[globalContext.currentFrameName].push_back("  mov eax, " + x86_temp_value);
    }
  } else {
    if(temp_type == DOUB){

      x86_function_map[globalContext.currentFrameName].push_back("  movss xmm0, " + TEMP_REG);
      updateRegisterAvailability(TEMP_REG, true);
    } else if(temp_type == INT){

      x86_function_map[globalContext.currentFrameName].push_back("  mov eax, " + TEMP_REG);
      updateRegisterAvailability(TEMP_REG, true);
    } else if(temp_type == BOOL){

      x86_function_map[globalContext.currentFrameName].push_back("  mov eax, " + TEMP_REG);
      updateRegisterAvailability(TEMP_REG, true);
    }
  }
  if(hasCond==false){
    // return
    if(globalContext.currentFrameName!="main"){
      if(function_call_map[globalContext.currentFrameName]==true){
        //push the inst to x86_code_inst
        x86_function_map[globalContext.currentFrameName].push_back("  leave");
        x86_function_map[globalContext.currentFrameName].push_back("  ret");
      } else{
  
        //push the inst to x86_code_inst
        x86_function_map[globalContext.currentFrameName].push_back("  pop rbp");
        x86_function_map[globalContext.currentFrameName].push_back("  ret");
      }
    } else{
      //push the inst to x86_code_inst
      x86_function_map[globalContext.currentFrameName].push_back("  leave");
      x86_function_map[globalContext.currentFrameName].push_back("  ret");

    }
  }
  else if(hasCond&&(NoBstmt==0||NoBstmt==1||NoBstmt==-1)){
    //for x86 assembly generator
    std::stringstream ss;
     ss << "  jmp "<<FinalEndLabel;
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    condHasReturn = true;
  }
}

void JLCX86Generator::visitVRet(VRet *v_ret)
{
  /* Code For VRet Goes Here */
  LLVM_builder_->CreateRetVoid();
  DEBUG_PRINT("visitVRet");
  //for x86 assembly generator
  std::stringstream ss;
  ss<<"  nop\n  leave\n  ret";
  x86_function_map[globalContext.currentFrameName].push_back(ss.str());

}

void JLCX86Generator::visitCond(Cond *cond)
{
  std::stringstream ss1;
  //nested cond
  if(NoBstmt==0&&isBstmt==0){
    ss1<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss1.str());
  }else if(NoBstmt==1&&isBstmt==0){
    ss1<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss1.str());
  }else if(NoBstmt==2&&isBstmt==0){
    ss1<<BStmtBlkEndLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss1.str());
  }else if(NoBstmt==-1&&isBstmt==0){
    ;
  } else if(NoBstmt==-2&&isBstmt==0){
    ;
  }

  /* Code For Cond Goes Here */
  hasCond = true;
  isBstmt = 0;
  auto current_block = LLVM_builder_->GetInsertBlock();
  auto parent = current_block->getParent();
  auto cond_true_block = llvm::BasicBlock::Create(
      *LLVM_Context_, "cond.true", parent);
  auto cond_end_block = llvm::BasicBlock::Create(
      *LLVM_Context_, "cond.end", parent);
  
  CondCounter++;
  BStmtBlkLabel = ".LB"+std::to_string(CondCounter);
  CondCounter++;
  BStmtBlkEndLabel = ".LB"+std::to_string(CondCounter);


  //store local label , use after visiting stmtblk
  auto localBlkLabel = BStmtBlkLabel;
  auto localBlkEndLabel = BStmtBlkEndLabel;

  if (cond->expr_) cond->expr_->accept(this);
  auto TEMP_REG0 = TEMP_REG;
  std::stringstream ss;
  if(x86_temp_value_type=="Imm"){
    auto reg = checkIntRegisterAvailability();
    ss << "  mov " << reg << ", " << x86_temp_value<<std::endl;
    ss << "  cmp "<<reg<<", 0"<<std::endl;
    ss << "  je " << BStmtBlkEndLabel;
  }else{
    ss << "  cmp "<<TEMP_REG0<<", 0"<<std::endl;
    ss << "  je " << BStmtBlkEndLabel;
    updateRegisterAvailability(TEMP_REG0,true);
  }
  
  x86_function_map[globalContext.currentFrameName].push_back(ss.str());

  NoBstmt = 0;


  auto func = globalContext.currentFrame();
  func.newBlock(); // just logic block, no need to create a label
  addBlockVarMap();// just logic block, no need to create a label

  addBlockVarInfoMap();


  if (cond->stmt_) cond->stmt_->accept(this);
  auto stmt_llvm_value = llvm_temp_value_;

    //insert the label to the cond end block
  std::stringstream ss2;
  ss2<<localBlkEndLabel<<":";
  x86_function_map[globalContext.currentFrameName].push_back(ss2.str());

  func.releaseBlock(); // release the logic block
  removeBlockVarMap(); // release the logic block
  removeBlockVarInfoMap(); // release the logic block

  NoBstmt = -2;
  isBstmt = 1;
}

void JLCX86Generator::visitCondElse(CondElse *cond_else)
{
  std::stringstream ss1;
  if(NoBstmt==0&&isBstmt==0){
    ss1<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss1.str());
  }else if(NoBstmt==1&&isBstmt==0){
    ss1<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss1.str());
  }else if(NoBstmt==2&&isBstmt==0){
    ss1<<BStmtBlkEndLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss1.str());
  }else if(NoBstmt==-1&&isBstmt==0){
    ;
  } else if(NoBstmt==-2&&isBstmt==0){
    ;
  }
  /* Code For CondElse Goes Here */
  hasCond = true;
  isBstmt = 0;
  auto current_block = LLVM_builder_->GetInsertBlock();
  auto parent = current_block->getParent();
  auto cond_true_block = llvm::BasicBlock::Create(
      *LLVM_Context_, "cond.true", parent);
  auto cond_else_block = llvm::BasicBlock::Create(
      *LLVM_Context_, "cond.else", parent);
  auto cond_end_block = llvm::BasicBlock::Create(
      *LLVM_Context_, "cond.end", parent);
  
  CondCounter++;
  BStmtBlkLabel = ".LB"+std::to_string(CondCounter);
  CondCounter++;
  BStmtBlkEndLabel = ".LB"+std::to_string(CondCounter);
  CondCounter++;
  BStmtBlkEndEndLabel = ".LB"+std::to_string(CondCounter);

  //store local label, use after visiting stmtblk
  auto localBlkLabel = BStmtBlkLabel;
  auto localBlkEndLabel = BStmtBlkEndLabel;
  auto localBlkEndEndLabel = BStmtBlkEndEndLabel;

  if (cond_else->expr_) cond_else->expr_->accept(this);
  auto TEMP_REG0 = TEMP_REG;
  std::stringstream ss;
  if(x86_temp_value_type=="Imm"){
    auto reg = checkIntRegisterAvailability();
    ss << "  mov " << reg << ", " << x86_temp_value<<std::endl;
    ss << "  cmp "<<reg<<", 0"<<std::endl;
    ss << "  je " << BStmtBlkEndLabel;
  }else{
    ss << "  cmp "<<TEMP_REG0<<", 0"<<std::endl;
    ss << "  je " << BStmtBlkEndLabel;
    updateRegisterAvailability(TEMP_REG0,true);
  }
  
  x86_function_map[globalContext.currentFrameName].push_back(ss.str());


  NoBstmt = 1;


  auto func = globalContext.currentFrame();
  func.newBlock(); // just logic block, no need to create a label
  addBlockVarMap();// just logic block, no need to create a label
  addBlockVarInfoMap();
  if (cond_else->stmt_1) cond_else->stmt_1->accept(this);
  auto stmt_1_llvm_value = llvm_temp_value_;
  func.releaseBlock(); // release the logic block
  removeBlockVarMap(); // release the logic block
  removeBlockVarInfoMap(); // release the logic block


  NoBstmt = 2;
  hasCond = true;//this value may be changed at last visitstmt


  func.newBlock(); // just logic block, no need to create a label
  addBlockVarMap();// just logic block, no need to create a label
  addBlockVarInfoMap();
  if (cond_else->stmt_2) cond_else->stmt_2->accept(this);
  auto stmt_2_llvm_value = llvm_temp_value_;
  func.releaseBlock(); // release the logic block
  removeBlockVarMap(); // release the logic block
  removeBlockVarInfoMap(); // release the logic block

  //restore default
  NoBstmt = -2;
  std::stringstream ss2;
  ss2 << localBlkEndEndLabel<<":";
  x86_function_map[globalContext.currentFrameName].push_back(ss2.str());
  isBstmt = 1;
}

void JLCX86Generator::visitWhile(While *while_)
{
  std::stringstream sss;
  if(NoBstmt==0&&isBstmt==0){
    sss<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(sss.str());
  }else if(NoBstmt==1&&isBstmt==0){
    sss<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(sss.str());
  }else if(NoBstmt==2&&isBstmt==0){
    sss<<BStmtBlkEndLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(sss.str());
  }else if(NoBstmt==-1&&isBstmt==0){
    ;
  } else if(NoBstmt==-2&&isBstmt==0){
    ;
  }
  /* Code For While Goes Here */
  hasCond = true;
  isBstmt = 0;
  auto current_block = LLVM_builder_->GetInsertBlock();
  auto parent = current_block->getParent();
  auto cond_block = llvm::BasicBlock::Create(
      *LLVM_Context_, "while.cond", parent);
  auto loop_block = llvm::BasicBlock::Create(
      *LLVM_Context_, "while.loop", parent);
  auto end_block = llvm::BasicBlock::Create(
      *LLVM_Context_, "while.end", parent);

  NoBstmt = -1;
  CondCounter++;
  BStmtBlkLabel = ".LB"+std::to_string(CondCounter);
  CondCounter++;
  BStmtBlkEndLabel = ".LB"+std::to_string(CondCounter);

  //store local label, for the jump instruction
  auto localBlkLabel = BStmtBlkLabel;
  auto localBlkEndLabel = BStmtBlkEndLabel;


  std::stringstream ss;
  ss<<BStmtBlkLabel<<":";
  x86_function_map[globalContext.currentFrameName].push_back(ss.str());


  if (while_->expr_) while_->expr_->accept(this);
  auto TEMP_REG0 = TEMP_REG;
  std::stringstream ss2;
  if(x86_temp_value_type=="Imm"){
     auto reg = checkIntRegisterAvailability();
    ss << "  mov " << reg << ", " << x86_temp_value<<std::endl;
    ss << "  cmp "<<reg<<", 0"<<std::endl;
    ss << "  je " << BStmtBlkEndLabel;
  }else{
    ss2 << "  cmp "<<TEMP_REG0<<", 0"<<std::endl;
    ss2 << "  je " << BStmtBlkEndLabel;
    updateRegisterAvailability(TEMP_REG0,true);
  }
  
  x86_function_map[globalContext.currentFrameName].push_back(ss2.str());


  // create a new block for the loop
  auto func = globalContext.currentFrame();
  func.newBlock(); // just logic block, no need to create a label
  addBlockVarMap();// just logic block, no need to create a label
  addBlockVarInfoMap();
  if (while_->stmt_) while_->stmt_->accept(this);

  // insert the jump back to the while start

  std::stringstream ss3;
  ss3<<"  jmp "<<localBlkLabel;
  x86_function_map[globalContext.currentFrameName].push_back(ss3.str());

  std::stringstream ss1;
  ss1<<localBlkEndLabel<<":";
  x86_function_map[globalContext.currentFrameName].push_back(ss1.str());
  
  auto stmt_llvm_value = llvm_temp_value_;
  LLVM_builder_->CreateBr(cond_block);
  func.releaseBlock(); // release the logic block
  removeBlockVarMap(); // release the logic block
  removeBlockVarInfoMap(); // release the logic block


  NoBstmt = -2;
  isBstmt = 1;
}


void JLCX86Generator::visitForBlk(ForBlk *for_blk)
{
  /* Code For ForBlk Goes Here */

  if (for_blk->type_) for_blk->type_->accept(this);
  if (for_blk->item_) for_blk->item_->accept(this);
  if (for_blk->stmt_) for_blk->stmt_->accept(this);

}


void JLCX86Generator::visitForLoop(ForLoop *for_loop)
{
  /* Code For ForLoop Goes Here */

  if (for_loop->stmt_) for_loop->stmt_->accept(this);

}

void JLCX86Generator::visitSExp(SExp *s_exp)
{
  /* Code For SExp Goes Here */
    std::stringstream ss;
  if(NoBstmt==0&&isBstmt==0){
    ss<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }else if(NoBstmt==1&&isBstmt==0){
    ss<<BStmtBlkLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }else if(NoBstmt==2&&isBstmt==0){
    ss<<BStmtBlkEndLabel<<":";
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }else if(NoBstmt==-1&&isBstmt==0){
    ;
  } else if(NoBstmt==-2&&isBstmt==0){
    ;
  }
  if (s_exp->expr_) s_exp->expr_->accept(this);

  if(NoBstmt==1&&isBstmt==0){
    std::stringstream ss;
    ss<<"  jmp "<<BStmtBlkEndEndLabel;
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }else if(NoBstmt==-1&&isBstmt==0){
    // std::stringstream ss;
    // ss<<"  jmp "<<BStmtBlkLabel;
    // x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }

}

void JLCX86Generator::visitNoInit(NoInit *no_init)
{
  /* Code For NoInit Goes Here */
  visitIdent(no_init->ident_);
  auto temp_decl_type = temp_type; // !this type is passed from top level
  auto & frame = globalContext.currentFrame();
  frame.addVar(no_init->ident_, temp_decl_type);

  
  llvm::Constant* init_val = nullptr;
  switch (temp_decl_type)
  {
  case INT:
    init_val = llvm::ConstantInt::get(*LLVM_Context_, llvm::APInt(32, 0));
    break;
  case DOUB:
    init_val = llvm::ConstantFP::get(*LLVM_Context_, llvm::APFloat(0.0));
    break;
  default:
    break;
  }
  /*todo: this should be an optional part, 
    which initialize the variable when allocates the memory
    now we just first allocate the memory, and then use sort to initialize the memory
  */ 
  // auto alloca = LLVM_builder_->CreateAlloca(convertType(temp_type), init_val, no_init->ident_);
  auto alloca = LLVM_builder_->CreateAlloca(convertType(temp_type), nullptr, no_init->ident_);
  addVarToBlockMap(no_init->ident_, alloca);
  if (init_val != nullptr)
  {
    LLVM_builder_->CreateStore(init_val, alloca);
    //@TODO: a better way to add comments
    llvm::MDNode* N = llvm::MDNode::get(*LLVM_Context_, 
      llvm::MDString::get(*LLVM_Context_, "Default value: 0"));
    alloca->setMetadata("comment", N);
  }
  addVarToStackMap(no_init->ident_, alloca);
  

  int stkptr = getStackTop();
  
  addVarInfoToBlockMap(no_init->ident_, alloca, stkptr,"");
  std::stringstream ss;
  if(temp_type == INT){
    ss << "  mov dword [rbp" << stkptr << "], " << "0";
  } else if(temp_type == DOUB){
    std::string FPNum;
    std::string floatIdentifier;
    auto noinitFP = std::to_string(0.0);
    if(checkDoubleFPMap(noinitFP)==true){
      FPNum = getDoubleFPMap(noinitFP);
      floatIdentifier = " "+FPNum +" dd "+noinitFP+"\n";
    } else{
      FPCounter++;
      FPNum ="FP" + std::to_string(FPCounter);
      floatIdentifier = " "+FPNum +" dd "+noinitFP+"\n";
      //update the string in FPRecord
      addDoubleFPMap(noinitFP, FPNum);
      FPRecord += floatIdentifier;
    }
    ss << "  movss xmm0, dword [" << FPNum << "]" << std::endl;
    ss << "  movss dword [rbp" << stkptr << "], " << "xmm0";
  }
  
  std::string inst = ss.str();
  x86_function_map[globalContext.currentFrameName].push_back(inst);
}

void JLCX86Generator::visitInit(Init *init)
{
  /* Code For Init Goes Here */
  visitIdent(init->ident_);
  auto temp_decl_type = temp_type; 
  auto & frame = globalContext.currentFrame();
  
  //addVarToStackMap(init->ident_, alloca);
  if (init->expr_) init->expr_->accept(this);
  
  // why we add the var after xx->accept(this)?
  // consider the case:  int x=1; {int x = x;}
  frame.addVar(init->ident_, temp_decl_type);
 

  auto alloca = LLVM_builder_->CreateAlloca(convertType(temp_decl_type), nullptr, init->ident_);
  // add the variable to the block map
  addVarToBlockMap(init->ident_, alloca);
  addVarToStackMap(init->ident_, alloca);
  
  // store a constant value to the memory
  LLVM_builder_->CreateStore(llvm_temp_value_, alloca);

 

  //for x86 assembly generator
  // update the stack frame space change after each variable init
  if (temp_decl_type == INT)
  {

    //get the stack top
    int stkptr = getStackTop();
    //std::cout << "  mov dword [rbp" << stkptr << "], " << x86_temp_value<< std::endl;
    // addVarInfoToBlockMap(init->ident_, alloca, stkptr,"");

    std::stringstream ss;
    if(x86_temp_value_type == "Imm"){
      ss << "  mov dword [rbp" << stkptr << "], " << x86_temp_value;
    } else{
      ss << "  mov dword [rbp" << stkptr << "], " << TEMP_REG;
      updateRegisterAvailability(TEMP_REG, true);
    }
    addVarInfoToBlockMap(init->ident_, alloca, stkptr,"");
    std::string inst = ss.str();
    x86_function_map[globalContext.currentFrameName].push_back(inst);
  }
  else if (temp_decl_type == DOUB)
  {
    int stkptr = getStackTop();
    //std::cout << "  movsd QWORD PTR [rbp" << stkptr<< "], " << x86_temp_value << std::endl;
    // addVarInfoToBlockMap(init->ident_, alloca, stkptr,"");
    
    std::stringstream ss;
    if(x86_temp_value_type == "Imm"){
      ss << "  movss dword [rbp" << stkptr<< "], " << x86_temp_FPregister;
      updateRegisterAvailability(x86_temp_FPregister, true);
    } else{
      ss << "  movss dword [rbp" << stkptr<< "], " << TEMP_REG;
      updateRegisterAvailability(TEMP_REG, true);
    }
    addVarInfoToBlockMap(init->ident_, alloca, stkptr,"");
    std::string inst = ss.str();
    x86_function_map[globalContext.currentFrameName].push_back(inst);

  } else if(temp_decl_type ==BOOL){
    auto stkptr = getStackTop();
    
    std::stringstream ss;

    
    if(x86_temp_value_type == "Imm"){//true, false
      ss <<"  mov byte [rbp" << stkptr<< "], " << x86_temp_value << "\n";
    
    } else{ //var,func,or,and,rel..
      ss<<"  mov dword [rbp" << stkptr<< "], "<<TEMP_REG;
      updateRegisterAvailability(TEMP_REG, true);
    
    }
    addVarInfoToBlockMap(init->ident_, alloca, stkptr,"");
    std::string inst = ss.str();
    x86_function_map[globalContext.currentFrameName].push_back(inst);
  
  }
}

void JLCX86Generator::visitInitElem(InitElem *init_elem)
{
  /* Code For InitElem Goes Here */

  visitIdent(init_elem->ident_);
  if (init_elem->expr_) init_elem->expr_->accept(this);

}

void JLCX86Generator::visitInt(Int *int_)
{
  /* Code For Int Goes Here */
  temp_type = INT;

}

void JLCX86Generator::visitDoub(Doub *doub)
{
  /* Code For Doub Goes Here */
  temp_type = DOUB;
}

void JLCX86Generator::visitBool(Bool *bool_)
{
  /* Code For Bool Goes Here */
  temp_type = BOOL;
}

void JLCX86Generator::visitVoid(Void *void_)
{
  /* Code For Void Goes Here */
  temp_type = VOID;
}

void JLCX86Generator::visitIntArray(IntArray *int_array)
{
  /* Code For IntArray Goes Here */
  temp_type = INTARRAY;

}

void JLCX86Generator::visitDoubArray(DoubArray *doub_array)
{
  /* Code For DoubArray Goes Here */
  temp_type = DOUBARRAY;

}

void JLCX86Generator::visitBoolArray(BoolArray *bool_array)
{
  /* Code For BoolArray Goes Here */
  temp_type = BOOLARRAY;

}

void JLCX86Generator::visitFun(Fun *fun)
{
  /* Code For Fun Goes Here */

  if (fun->type_) fun->type_->accept(this);
  if (fun->listtype_) fun->listtype_->accept(this);

}

void JLCX86Generator::visitEVar(EVar *e_var)
{
  /* Code For EVar Goes Here */
  auto & frame = globalContext.currentFrame();
  temp_type = frame.getVarType(e_var->ident_);
  // visitIdent(e_var->ident_);
  
  // when we access a variable, we need to load the value from the memory
  // llvm load 
  llvm::Value* var = getVarFromBlockMap(e_var->ident_);
  setLLVMTempValue( LLVM_builder_->CreateLoad(convertType(temp_type), var, e_var->ident_));

  x86_temp_value = e_var->ident_;
  x86_temp_value_type = "Var";
  //for x86 assembly generator
  auto varInfo = getVarInfoFromBlockMap(e_var->ident_);
  // get the location from varInfo
  auto stkloc = varInfo->stack_location;

  //check
  // allocate the stack location to one register, for example, eax , and update the the status from true to false in register_map
  if (temp_type == INT)
  {
 
    auto reg = checkIntRegisterAvailability();
    TEMP_REG = reg;
    if (reg =="")
    {//TODO:handle the case when there is no available register
      std::cerr << "ERROR: no available register for int type\n";
      exit(1);
    }
    else
    {
      //std::cout << "  mov " << reg << ", dword [rbp" << stkloc << "]" << std::endl;
      updateRegisterAvailability(reg, false);
      updateVarInfoRegisterName(e_var->ident_, reg);
      

      //push the inst to x86_code_inst
      std::stringstream ss;
      ss << "  mov " << reg << ", dword [rbp" << stkloc << "]";
      std::string inst = ss.str();
      x86_function_map[globalContext.currentFrameName].push_back(inst);
    }
  }
  else if (temp_type == DOUB)
  {
    auto reg = checkDoubleRegisterAvailability();
    TEMP_REG = reg;
    if (reg == "")
    {
      std::cerr << "ERROR: no available register for double type\n";
      exit(1);
    }
    else
    {
      
      updateRegisterAvailability(reg, false);
      updateVarInfoRegisterName(e_var->ident_, reg);

      //push the inst to x86_code_inst
      std::stringstream ss;
      ss << "  movss " << reg << ", dword [rbp" << stkloc << "]";
      std::string inst = ss.str();
      x86_function_map[globalContext.currentFrameName].push_back(inst);
      
    }
  }else if(temp_type ==BOOL){
    auto reg = checkIntRegisterAvailability();
    TEMP_REG = reg;

    updateRegisterAvailability(reg, false);
    updateVarInfoRegisterName(e_var->ident_, reg);

    //push the inst to x86_code_inst
    std::stringstream ss;
    ss << "  movzx " << reg << ", byte [rbp" << stkloc << "]";
    std::string inst = ss.str();
    x86_function_map[globalContext.currentFrameName].push_back(inst);
  }




}

void JLCX86Generator::visitEArrayNew(EArrayNew *e_array_new)
{
  /* Code For EArrayNew Goes Here */

  if (e_array_new->expr_) e_array_new->expr_->accept(this);
  if(temp_type != INT){
    std::cerr << "ERROR: can just declare a array of [] int type\n";
    exit(1);
  }

  if (e_array_new->type_) e_array_new->type_->accept(this);
  if(temp_type == VOID){
    std::cerr << "ERROR: cannot declare a array variable with void type\n";
    exit(1);
  }
  if(temp_type == INT) temp_type = INTARRAY;
  if(temp_type == DOUB) temp_type = DOUBARRAY;
  if(temp_type == BOOL) temp_type = BOOLARRAY;
}

void JLCX86Generator::visitEArrayLen(EArrayLen *e_array_len)
{
  /* Code For EArrayLen Goes Here */

  if (e_array_len->expr_1) e_array_len->expr_1->accept(this);
  if (e_array_len->expr_2) e_array_len->expr_2->accept(this);

}

void JLCX86Generator::visitEArray(EArray *e_array)
{
  /* Code For EArray Goes Here */

  if (e_array->expr_1) e_array->expr_1->accept(this);
  if (e_array->expr_2) e_array->expr_2->accept(this);

}


void JLCX86Generator::visitELitInt(ELitInt *e_lit_int)
{
  /* Code For ELitInt Goes Here */

  visitInteger(e_lit_int->integer_);
  temp_type = INT;
  
  x86_temp_value = std::to_string(e_lit_int->integer_);

  x86_temp_value_type = "Imm";
  // llvm constant
  setLLVMTempValue( llvm::ConstantInt::get(*LLVM_Context_, llvm::APInt(32, e_lit_int->integer_)));
  
}

void JLCX86Generator::visitELitDoub(ELitDoub *e_lit_doub)
{
  /* Code For ELitDoub Goes Here */

  visitDouble(e_lit_doub->double_);
  temp_type = DOUB;
  std::string FPNum;
  std::string floatIdentifier;

  x86_temp_value = std::to_string(e_lit_doub->double_);
  if(checkDoubleFPMap(x86_temp_value)==true){
    FPNum = getDoubleFPMap(x86_temp_value);
    floatIdentifier = " "+FPNum +" dd "+x86_temp_value+"\n";
  } else{
    FPCounter++;
    FPNum ="FP" + std::to_string(FPCounter);
    floatIdentifier = " "+FPNum +" dd "+x86_temp_value+"\n";
    //update the string in FPRecord
    addDoubleFPMap(x86_temp_value, FPNum);
    FPRecord += floatIdentifier;
  }

  //push the inst to x86_code_inst
  auto reg = checkDoubleRegisterAvailability();
  
  std::stringstream ss;
  ss << "  movss " << reg << ", dword "<<"["<<FPNum<<"]";
  std::string inst = ss.str();
  x86_function_map[globalContext.currentFrameName].push_back(inst);
  updateRegisterAvailability(reg, false);
  x86_temp_FPregister = reg;

  x86_temp_value_type = "Imm";
  // llvm constant
  setLLVMTempValue(llvm::ConstantFP::get(*LLVM_Context_, llvm::APFloat(e_lit_doub->double_)));
}

void JLCX86Generator::visitELitTrue(ELitTrue *e_lit_true)
{
  /* Code For ELitTrue Goes Here */

  temp_type = BOOL;
  x86_temp_value_type = "Imm";
  x86_temp_value = std::to_string(1);

  // llvm constant 
  setLLVMTempValue( llvm::ConstantInt::get(*LLVM_Context_, llvm::APInt(1, 1)));

}

void JLCX86Generator::visitELitFalse(ELitFalse *e_lit_false)
{
  /* Code For ELitFalse Goes Here */
  temp_type = BOOL;
  x86_temp_value_type = "Imm";
  x86_temp_value = std::to_string(0);
  // llvm constant
  setLLVMTempValue( llvm::ConstantInt::get(*LLVM_Context_, llvm::APInt(1, 0)));

}

void JLCX86Generator::visitEApp(EApp *e_app)
{
  DEBUG_PRINT("Visit EApp: " + e_app->ident_);
  function_call_map[globalContext.currentFrameName] = true;

  std::vector<llvm::Value*> args;
  //store temp stack location for spill
  std::vector<std::string> temp_stack_location;
  //store type of each argument
  std::vector<type_enum> arg_types;
  for (auto & expr : *(e_app->listexpr_))
  {
    expr->accept(this);
    //args.push_back(llvm_temp_value_);

    //for x86 func call
    DEBUG_PRINT("x86 func call")

    if(x86_temp_value_type=="Imm"){

      std::stringstream ss;
      if(temp_type == DOUB){

        updateRegisterAvailability(x86_temp_FPregister, true);

        // at this time the x86_temp_Value is a reg
        if(e_app->ident_=="printDouble"){
              
          auto reg = popArgFromFunctionMap(DOUB);
          ss << "  cvtss2sd " << reg << ", " << x86_temp_FPregister;
        }else{
          addVarToStackMap("", nullptr);
          temp_stack_location.push_back(std::to_string(getStackTop()));//spill
          ss << "  movss " << "dword [rbp" << getStackTop() << "], " << x86_temp_FPregister;
          arg_types.push_back(DOUB);
        }
      } else if(temp_type == INT){
        addVarToStackMap("", nullptr);
        temp_stack_location.push_back(std::to_string(getStackTop()));//spill
        ss << "  mov " << "dword [rbp" << getStackTop() << "], " << x86_temp_value;
        arg_types.push_back(INT);
      } else if(temp_type == BOOL){
        addVarToStackMap("", nullptr);
        temp_stack_location.push_back(std::to_string(getStackTop()));//spill
        ss << "  mov " << "byte [rbp" << getStackTop() << "], " << x86_temp_value;
        arg_types.push_back(BOOL);
      }
      std::string inst = ss.str();
      x86_function_map[globalContext.currentFrameName].push_back(inst);
    } else if(x86_temp_value_type=="Str"){
      ;
    } 
    else{
      
      std::stringstream ss;
      if(temp_type == DOUB){

        if(e_app->ident_=="printDouble"){//this function dont need to spill
          auto reg = popArgFromFunctionMap(DOUB);
          ss << "  cvtss2sd " << reg << ", " << TEMP_REG;
          updateRegisterAvailability(TEMP_REG, true);
        }else{
          addVarToStackMap("", nullptr);
          temp_stack_location.push_back(std::to_string(getStackTop()));//spill
          ss << "  movss " << "dword [rbp" << getStackTop() << "], " << TEMP_REG;
          updateRegisterAvailability(TEMP_REG, true);
          arg_types.push_back(DOUB);
        }
      } else if(temp_type == INT){
        addVarToStackMap("", nullptr);
        temp_stack_location.push_back(std::to_string(getStackTop()));//spill
        ss << "  mov " << "dword [rbp" << getStackTop() << "], " << TEMP_REG;
        updateRegisterAvailability(TEMP_REG, true);
        arg_types.push_back(INT);
      }else if(temp_type == BOOL){//for bool func
        addVarToStackMap("", nullptr);
        temp_stack_location.push_back(std::to_string(getStackTop()));//spill
        ss << "  mov " << "dword [rbp" << getStackTop() << "], " << TEMP_REG;
        updateRegisterAvailability(TEMP_REG, true);
        arg_types.push_back(BOOL);
      }
      
      std::string inst = ss.str();
      x86_function_map[globalContext.currentFrameName].push_back(inst);
    }
  }
  if(e_app->ident_!="printDouble"&&e_app->ident_!="readDouble"&&e_app->ident_!="readInt"){
    //if function is not printDouble..., loop types
    for(auto & arg_type: arg_types){
      auto reg = popArgFromFunctionMap(arg_type);
      if(reg!=""){
        updateRegisterAvailability(reg, false);
        if(arg_type == INT){
          std::stringstream ss;
          ss << "  mov " << reg << ", " << "dword [rbp" << temp_stack_location.front() << "]";
          temp_stack_location.erase(temp_stack_location.begin());
          std::string inst = ss.str();
          x86_function_map[globalContext.currentFrameName].push_back(inst);
        } else if(arg_type == DOUB){
          std::stringstream ss;
          ss << "  movss " << reg << ", " << "dword [rbp" << temp_stack_location.front() << "]";
          temp_stack_location.erase(temp_stack_location.begin());
          std::string inst = ss.str();
          x86_function_map[globalContext.currentFrameName].push_back(inst);
        } else if(arg_type == BOOL){
          std::stringstream ss;
          ss << "  movzx " << reg << ", " << "byte [rbp" << temp_stack_location.front() << "]";
          temp_stack_location.erase(temp_stack_location.begin());
          std::string inst = ss.str();
          x86_function_map[globalContext.currentFrameName].push_back(inst);
        }
      }else{//spill(not implement bool type yet)
        std::stringstream ss;
        if(arg_type == INT){
          auto reg = checkIntRegisterAvailability();
          ss << "  mov " << reg << ", " << "dword [rbp" << temp_stack_location.front() << "]"<<std::endl;
          ss << "  mov " << "dword [rsp+" << register_spill_location.size()*4 << "], " << reg;
          temp_stack_location.erase(temp_stack_location.begin());
          register_spill_location.push_back(register_spill_location.size()*4);
        } else if(arg_type == DOUB){
          auto reg = checkDoubleRegisterAvailability();
          ss << "  movss " << reg << ", " << "dword [rbp" << temp_stack_location.front() << "]"<<std::endl;
          ss << "  movss " << "dword [rsp+" << register_spill_location.size()*4 << "], " << reg;
          temp_stack_location.erase(temp_stack_location.begin());
          register_spill_location.push_back(register_spill_location.size()*4);
        }
        
        std::string inst = ss.str();
        x86_function_map[globalContext.currentFrameName].push_back(inst);
        
      }

    }
  }
  

  restoreFunctionArgQueue();//restore args reg availability

  // add llvm function call
  auto llvm_func = LLVM_module_->getFunction(e_app->ident_);
  // check if the return type is void
  std::string tag = "";
  DEBUG_PRINT("EApp check return type")
  if (!llvm_func->getReturnType()->isVoidTy())
  {
    DEBUG_PRINT("EApp return type is not void")
    // if return type is void, then we have to pass empty string as tag
    tag = e_app->ident_;
  }
  DEBUG_PRINT("EApp create call")
  setLLVMTempValue( LLVM_builder_->CreateCall(llvm_func, args, tag));
  DEBUG_PRINT("Call function: " + e_app->ident_);


  //push the inst to x86_code_inst
  //before call this function, we need to check if the eax is available? //TODO
    std::stringstream ss;
    ss << "  call " << e_app->ident_;
    std::string inst = ss.str();
    x86_function_map[globalContext.currentFrameName].push_back(inst);
  


  Frame& func = globalContext.getFrame(e_app->ident_);

  temp_type = func.returnType;
  

   if(e_app->ident_=="readDouble"){
    std::stringstream ss1;
    ss1 << "  cvtsd2ss " << "xmm0, " << "xmm0";
    std::string inst = ss1.str();
    x86_function_map[globalContext.currentFrameName].push_back(inst);
    temp_type = DOUB;
  }else if(e_app->ident_=="readInt"){
    temp_type = INT;
  }

  x86_temp_value_type = "Fun";

  if(temp_type == INT){
    TEMP_REG = "eax";
  }
  else if(temp_type == DOUB){
    TEMP_REG = "xmm0";
  }else if(temp_type == BOOL){
    std::stringstream ss;
    auto reg = checkIntRegisterAvailability();
    updateRegisterAvailability(reg, false); 
    ss << "  movzx " << reg << ", " << "al";
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    TEMP_REG = reg;
  }
   
}

void JLCX86Generator::visitEString(EString *e_string)
{
  /* Code For EString Goes Here */
  temp_type = STRING;
  x86_temp_value_type="Str";
  // check if the string is already in the global context
  // @TODO: this is not a good way to store the string, 
  //        using llvm api to check if a string is already in the global context
  // why we convert string to id? Considering the case a very long string.
  static int global_string_id = 0;
  static std::map<std::string, int> string_id_map;
  static std::map<int, llvm::GlobalVariable*> global_sid_var_map;
  
  
  //for x86 assembly generator
  std::string StrNum;
  std::string StrIdentifier;

  auto temp_str = e_string->string_;
  if(checkStringMap(temp_str)==true){
    StrNum = getStringMap(temp_str);
    StrIdentifier = " "+StrNum +" db "+temp_str+", 0\n";
  } else{
    StrCounter++;
    StrNum ="Str" + std::to_string(StrCounter);
    StrIdentifier = " "+StrNum +" db "+"\""+temp_str+"\""+", 0\n";
    //update the string in FPRecord
    addStringMap(temp_str, StrNum);
    StrRecord += StrIdentifier;
  }

  //push the inst to x86_code_inst
  std::stringstream ss;
  ss << "  lea rdi, " << "[" << StrNum << "]";
  std::string inst = ss.str();
  x86_function_map[globalContext.currentFrameName].push_back(inst);
}

void JLCX86Generator::visitNeg(Neg *neg)
{
  /* Code For Neg Goes Here */

  if (neg->expr_) neg->expr_->accept(this);
  // llvm neg
  // if value is int, then we use CreateNeg
  if(temp_type == INT)
  {
    if(x86_temp_value_type=="Imm"){
    x86_temp_value = "-" + x86_temp_value;
    }
    else{
      //for x86 assembly generator
      std::stringstream ss;
      ss<<"  neg " << TEMP_REG;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    
    }
  }
  else
  {
    auto reg = checkDoubleRegisterAvailability();
    if(x86_temp_value_type=="Imm"){
      std::stringstream ss;
      
      ss<<"  movups " << reg << ", " << "[negmask]"<<std::endl;
      ss <<"  xorps "<< x86_temp_FPregister << ", " << reg;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    }else{
      //for x86 assembly generator
      std::stringstream ss;
      ss<<"  movups " << reg << ", " << "[negmask]"<<std::endl;
      ss<<"  xorps " << TEMP_REG << ", " << reg;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    }

  }
  
}

void JLCX86Generator::visitNot(Not *not_)
{
  /* Code For Not Goes Here */

  if (not_->expr_) not_->expr_->accept(this);
  if(x86_temp_value_type=="Imm"){
    x86_temp_value = x86_temp_value=="0"?"1":"0";
  }else{
    auto TEMP_REG0 = TEMP_REG;
    std::stringstream ss;
    ss<<"  xor " << TEMP_REG0 << ", 1";
  
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    TEMP_REG = TEMP_REG0;
  }
  

}

void JLCX86Generator::visitEMul(EMul *e_mul)
{
  /* Code For EMul Goes Here */
  updateRegisterAvailability("eax", false);
  updateRegisterAvailability("xmm0", false);
  if (e_mul->expr_1) e_mul->expr_1->accept(this);
  auto expr_1_llvm_value = llvm_temp_value_;
  auto expr_1_x86_temp_value = x86_temp_value;
  auto expr_1_x86_temp_value_type = x86_temp_value_type;
  auto TEMP_REG1=TEMP_REG;
  int STKLOC1;
  if(expr_1_x86_temp_value_type=="Fun"||expr_1_x86_temp_value_type=="Var"){
      TEMP_REG1 = spillRegister(TEMP_REG1, temp_type);
      STKLOC1=getStackTop();
  }
  
  if (e_mul->mulop_) e_mul->mulop_->accept(this);
  auto local_op = temp_op;
  if (e_mul->expr_2) e_mul->expr_2->accept(this);
  auto expr_2_llvm_value = llvm_temp_value_;
  auto expr_2_x86_temp_value = x86_temp_value;
  auto expr_2_x86_temp_value_type = x86_temp_value_type;
  auto TEMP_REG2=TEMP_REG;
  int STKLOC2;
  if(expr_2_x86_temp_value_type=="Fun"){
      TEMP_REG2 = spillRegister(TEMP_REG2, temp_type);
      STKLOC2=getStackTop();
  }


  if(temp_type==INT)
  {
    //for immediate value
    if(expr_1_x86_temp_value_type=="Imm"&&expr_2_x86_temp_value_type!="Imm"){
      std::stringstream ss;
      if(local_op==eMUL){
        ss <<"  imul " << TEMP_REG2<<", " << expr_1_x86_temp_value;
        TEMP_REG = TEMP_REG2;
      } else if(local_op==eDIV){
        ss <<"  mov eax, " << expr_1_x86_temp_value << std::endl;
        ss <<"  cdq" << std::endl;
        ss <<"  idiv " << TEMP_REG2;
        TEMP_REG = "eax";
      } else if(local_op==eMOD){
        ss <<"  mov eax, " << expr_1_x86_temp_value << std::endl;
        ss <<"  cdq" << std::endl;
        ss <<"  idiv " << TEMP_REG2;
        TEMP_REG = "edx";
      }
      updateRegisterAvailability(TEMP_REG2, true);
      x86_temp_value_type =expr_2_x86_temp_value_type;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
      
    } else if(expr_1_x86_temp_value_type!="Imm"&&expr_2_x86_temp_value_type=="Imm"){
      std::stringstream ss;
      if(local_op==eMUL){
        ss <<"  imul " << TEMP_REG1<<", " << expr_2_x86_temp_value;
        TEMP_REG = TEMP_REG1;
      } else if(local_op==eDIV){
        ss <<"  mov eax, " << TEMP_REG1 << std::endl;
        auto reg = checkIntRegisterAvailability();
        ss <<"  mov " << reg << ", " << expr_2_x86_temp_value << std::endl;
        ss <<"  cdq" << std::endl;
        ss <<"  idiv " << reg;
        TEMP_REG = "eax";
      } else if(local_op==eMOD){
        ss <<"  mov eax, " << TEMP_REG1 << std::endl;
        auto reg = checkIntRegisterAvailability();
        ss <<"  mov " << reg << ", " << expr_2_x86_temp_value << std::endl;
        ss <<"  cdq" << std::endl;
        ss <<"  idiv " << reg;
        TEMP_REG = "edx";
      }
      updateRegisterAvailability(TEMP_REG1, true);
      x86_temp_value_type =expr_1_x86_temp_value_type;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    } else if(expr_1_x86_temp_value_type=="Imm"&&expr_2_x86_temp_value_type=="Imm"){
      if(local_op==eMUL){
        auto ival = std::stoi(expr_1_x86_temp_value)*std::stoi(expr_2_x86_temp_value);
        x86_temp_value = std::to_string(ival);
        x86_temp_value_type ="Imm";
      }else if(local_op==eDIV){
        auto ival = std::stoi(expr_1_x86_temp_value)/std::stoi(expr_2_x86_temp_value);
        x86_temp_value = std::to_string(ival);
        x86_temp_value_type ="Imm";
      }else if(local_op==eMOD){
        auto ival = std::stoi(expr_1_x86_temp_value)%std::stoi(expr_2_x86_temp_value);
        x86_temp_value = std::to_string(ival);
        x86_temp_value_type ="Imm";
      }
    } else{
      //TO DO , reg allocation: spill..
      std::stringstream ss;
      if((expr_1_x86_temp_value_type=="Var"&&expr_2_x86_temp_value_type=="Fun")||(expr_1_x86_temp_value_type=="Fun"&&expr_2_x86_temp_value_type=="Fun")){
        ss << "  mov " << TEMP_REG1 << ", " << "dword [rbp" << STKLOC1<< "]" << std::endl;
      }
      if(local_op==eMUL){
        ss << "  imul " << TEMP_REG1 << ", " << TEMP_REG2;
        x86_temp_value_type =expr_1_x86_temp_value_type;
        TEMP_REG = TEMP_REG1;
        updateRegisterAvailability(TEMP_REG1, false);
      } else if(local_op==eDIV){
        ss << "  mov eax, " << TEMP_REG1 << std::endl;
        ss << "  cdq" << std::endl;
        ss << "  idiv " << TEMP_REG2;
        x86_temp_value_type =expr_1_x86_temp_value_type;
        updateRegisterAvailability(TEMP_REG1, true);
        TEMP_REG = "eax";
      } else if(local_op==eMOD){
        ss << "  mov eax, " << TEMP_REG1 << std::endl;
        ss << "  cdq" << std::endl;
        ss << "  idiv " << TEMP_REG2;
        x86_temp_value_type =expr_1_x86_temp_value_type;
        updateRegisterAvailability(TEMP_REG1, true);
        TEMP_REG = "edx";
      }
      
      updateRegisterAvailability(TEMP_REG2, true);
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    }
  }
  else{
    if(expr_1_x86_temp_value_type=="Imm"&&expr_2_x86_temp_value_type!="Imm"){
      std::stringstream ss;
      if(local_op==eMUL){
        ss <<"  mulss " << TEMP_REG2<<", " << x86_temp_FPregister;
        TEMP_REG = TEMP_REG2;
      } else if(local_op==eDIV){
        ss <<"  divss " << TEMP_REG2<<", " << x86_temp_FPregister;
        TEMP_REG = TEMP_REG2;
      }
      updateRegisterAvailability(x86_temp_FPregister, true);
      x86_temp_value_type =expr_2_x86_temp_value_type;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    } else if(expr_1_x86_temp_value_type!="Imm"&&expr_2_x86_temp_value_type=="Imm"){
      std::stringstream ss;
      if(local_op==eMUL){
        ss <<"  mulss " << TEMP_REG1<<", " << x86_temp_FPregister;
        TEMP_REG = TEMP_REG1;
      } else if(local_op==eDIV){
        ss <<"  divss " << TEMP_REG1<<", " << x86_temp_FPregister;
        TEMP_REG = TEMP_REG1;
      }
      updateRegisterAvailability(x86_temp_FPregister, true);
      x86_temp_value_type =expr_1_x86_temp_value_type;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    } else if(expr_1_x86_temp_value_type=="Imm"&&expr_2_x86_temp_value_type=="Imm"){
      if(local_op==eMUL){
        auto ival = std::stof(expr_1_x86_temp_value)*std::stof(expr_2_x86_temp_value);
        x86_temp_value = std::to_string(ival);
        x86_temp_value_type ="Imm";
      }else if(local_op==eDIV){
        auto ival = std::stof(expr_1_x86_temp_value)/std::stof(expr_2_x86_temp_value);
        x86_temp_value = std::to_string(ival);
        x86_temp_value_type ="Imm";
      }
    } else{
      std::stringstream ss;
      if((expr_1_x86_temp_value_type=="Var"&&expr_2_x86_temp_value_type=="Fun")||(expr_1_x86_temp_value_type=="Fun"&&expr_2_x86_temp_value_type=="Fun")){
        ss << "  movss " << TEMP_REG1 << ", " << "dword [rbp" << STKLOC1 << "]" << std::endl;
      }
      if(local_op==eMUL){
        ss << "  mulss " << TEMP_REG1 << ", " << TEMP_REG2;
        x86_temp_value_type =expr_1_x86_temp_value_type;
        TEMP_REG = TEMP_REG1;
        updateRegisterAvailability(TEMP_REG2, false);
      } else if(local_op==eDIV){
        ss << "  divss " << TEMP_REG1 << ", " << TEMP_REG2;
        x86_temp_value_type =expr_1_x86_temp_value_type;
        TEMP_REG = TEMP_REG1;
        updateRegisterAvailability(TEMP_REG2, false);
      }
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());

    }
      
  }
  
}

void JLCX86Generator::visitEAdd(EAdd *e_add)
{
  /* Code For EAdd Goes Here */
  if (e_add->expr_1) e_add->expr_1->accept(this);
  auto expr_1_llvm_value = llvm_temp_value_;
  auto expr_1_x86_temp_value = x86_temp_value;
  auto expr_1_x86_temp_value_type = x86_temp_value_type;
  auto TEMP_REG1=TEMP_REG;
  int STKLOC1;
  if(expr_1_x86_temp_value_type=="Fun"||expr_1_x86_temp_value_type=="Var"){
      TEMP_REG1 = spillRegister(TEMP_REG1, temp_type);
      STKLOC1=getStackTop();
  }

  if (e_add->addop_) e_add->addop_->accept(this);
  auto local_op = temp_op;
  if (e_add->expr_2) e_add->expr_2->accept(this);
  auto expr_2_llvm_value = llvm_temp_value_;
  auto expr_2_x86_temp_value = x86_temp_value;
  auto expr_2_x86_temp_value_type = x86_temp_value_type;
  auto TEMP_REG2=TEMP_REG;
  int STKLOC2;
  //reg allocation, to spill
  if(expr_2_x86_temp_value_type=="Fun"){
      TEMP_REG2 = spillRegister(TEMP_REG2, temp_type);
      STKLOC2=getStackTop();
  }
      
  if(temp_type==INT)
  {
    //for immediate value
    if(expr_1_x86_temp_value_type=="Imm"&&expr_2_x86_temp_value_type!="Imm"){

      auto reg = TEMP_REG2;
      std::stringstream ss;
      if(local_op==eADD)
        ss <<"  add " << reg<<", " << expr_1_x86_temp_value;
      else
        ss <<"  sub " << reg<<", " << expr_1_x86_temp_value;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
      x86_temp_value_type =expr_2_x86_temp_value_type;
      TEMP_REG = reg;
    } else if(expr_1_x86_temp_value_type!="Imm"&&expr_2_x86_temp_value_type=="Imm"){
      auto reg = TEMP_REG1;
      std::stringstream ss;
      if(local_op==eADD)
        ss <<"  add " << reg<<", " << expr_2_x86_temp_value;
      else
        ss <<"  sub " << reg<<", " << expr_2_x86_temp_value;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
       x86_temp_value_type =expr_1_x86_temp_value_type;
      TEMP_REG = reg;
    } else if(expr_1_x86_temp_value_type=="Imm"&&expr_2_x86_temp_value_type=="Imm"){
      if(local_op==eADD){
        auto ival = std::stoi(expr_1_x86_temp_value)+std::stoi(expr_2_x86_temp_value);
        x86_temp_value = std::to_string(ival);
        x86_temp_value_type ="Imm";
      }else if(local_op==eSUB){
        auto ival = std::stoi(expr_1_x86_temp_value)-std::stoi(expr_2_x86_temp_value);
        x86_temp_value = std::to_string(ival);
        x86_temp_value_type ="Imm";
      }
    } else{
      //reg allocation: spill
      std::stringstream ss;
      if((expr_1_x86_temp_value_type=="Var"&&expr_2_x86_temp_value_type=="Fun")||(expr_1_x86_temp_value_type=="Fun"&&expr_2_x86_temp_value_type=="Fun")){
        ss << "  mov " << TEMP_REG1 << ", " << "dword [rbp" << STKLOC1 << "]" << std::endl;
      }
      if(local_op==eADD){
        ss << "  add " << TEMP_REG1 << ", " << TEMP_REG2;
        TEMP_REG = TEMP_REG1;
        x86_temp_value_type =expr_1_x86_temp_value_type;
      } else{
        ss << "  sub " << TEMP_REG1 << ", " << TEMP_REG2;
        TEMP_REG = TEMP_REG1;
        x86_temp_value_type =expr_1_x86_temp_value_type;
      }
      updateRegisterAvailability(TEMP_REG2, true);
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    }

  }
  else
  {
    if(expr_1_x86_temp_value_type=="Imm"&&expr_2_x86_temp_value_type!="Imm"){
      auto reg = TEMP_REG2;
      std::stringstream ss;
      if(local_op==eADD)
        ss <<"  addss " << reg<<", " << x86_temp_FPregister;
      else
        ss <<"  subss " << reg<<", " << x86_temp_FPregister;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
      updateRegisterAvailability(x86_temp_FPregister, true);
      x86_temp_value_type =expr_2_x86_temp_value_type;
      TEMP_REG = reg;
    } else if(expr_1_x86_temp_value_type!="Imm"&&expr_2_x86_temp_value_type=="Imm"){
      auto reg = TEMP_REG1;
      std::stringstream ss;
      if(local_op==eADD)
        ss <<"  addss " << reg<<", " << x86_temp_FPregister;
      else
        ss <<"  subss " << reg<<", " << x86_temp_FPregister;
      updateRegisterAvailability(x86_temp_FPregister, true);
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
      x86_temp_value_type =expr_1_x86_temp_value_type;
      TEMP_REG = reg;
    } else{

      std::stringstream ss;
      if((expr_1_x86_temp_value_type=="Var"&&expr_2_x86_temp_value_type=="Fun")||(expr_1_x86_temp_value_type=="Fun"&&expr_2_x86_temp_value_type=="Fun")){//for fun recrusions
        ss << "  movss " << TEMP_REG1 << ", " << "dword [rbp" << STKLOC1 << "]" << std::endl;
      }
      if(local_op==eADD){
        ss << "  addss " << TEMP_REG1 << ", " << TEMP_REG2;
        x86_temp_value_type =expr_1_x86_temp_value_type;
        TEMP_REG = TEMP_REG1;
      } else{
        ss << "  subss " << TEMP_REG1 << ", " << TEMP_REG2;
        x86_temp_value_type =expr_1_x86_temp_value_type;
        TEMP_REG = TEMP_REG1;
      }
      updateRegisterAvailability(TEMP_REG2, true);
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    }
    
  }
 
}

void JLCX86Generator::visitERel(ERel *e_rel)
{
  /* Code For ERel Goes Here */
  updateRegisterAvailability("eax", false);
  //updateRegisterAvailability("al", false);
  if (e_rel->expr_1) e_rel->expr_1->accept(this);
  auto expr_1_llvm_value = llvm_temp_value_;
  auto expr_1_x86_temp_value = x86_temp_value;
  auto expr_1_x86_temp_value_type = x86_temp_value_type;
  auto TEMP_REG1=TEMP_REG;
  auto FP_REG1 = x86_temp_FPregister;//for fp imm
  
  if (e_rel->relop_) e_rel->relop_->accept(this);
  auto local_op = temp_op;

  
  if (e_rel->expr_2) e_rel->expr_2->accept(this);
  
  auto expr_2_llvm_value = llvm_temp_value_;
  auto expr_2_x86_temp_value = x86_temp_value;
  auto expr_2_x86_temp_value_type = x86_temp_value_type; 
  auto TEMP_REG2=TEMP_REG;
  auto FP_REG2 = x86_temp_FPregister;

  //for x86 assembly generator
  std::stringstream ss;

  // if value is int, then we use CreateICmpSLT
  if(temp_type == INT || temp_type ==BOOL)//bool is involved
  {
    
    //for x86 assembly generator
    
      if(expr_1_x86_temp_value_type=="Imm"&&expr_2_x86_temp_value_type!="Imm"){
        auto reg = checkIntRegisterAvailability();
        ss << "  mov " << reg << ", " << expr_1_x86_temp_value << std::endl;
        ss << "  cmp " << reg << ", " << TEMP_REG2;
        x86_function_map[globalContext.currentFrameName].push_back(ss.str());
        updateRegisterAvailability(TEMP_REG2, true);
      }else if(expr_1_x86_temp_value_type!="Imm"&&expr_2_x86_temp_value_type=="Imm"){
        ss << "  cmp " << TEMP_REG1 << ", " << expr_2_x86_temp_value;
        x86_function_map[globalContext.currentFrameName].push_back(ss.str());
        updateRegisterAvailability(TEMP_REG1, true);
      }else if(expr_1_x86_temp_value_type=="Imm"&&expr_2_x86_temp_value_type=="Imm"){
        auto reg = checkIntRegisterAvailability();
        ss << "  mov " << reg << ", " << expr_1_x86_temp_value << std::endl;
        ss << "  cmp " << reg << ", " << expr_2_x86_temp_value;
        x86_function_map[globalContext.currentFrameName].push_back(ss.str());
      }
      else{
        ss << "  cmp " << TEMP_REG1 << ", " << TEMP_REG2;
        x86_function_map[globalContext.currentFrameName].push_back(ss.str());
        updateRegisterAvailability(TEMP_REG1, true);
        updateRegisterAvailability(TEMP_REG2, true);
      }
           
  }
  else
  {
  
    if(expr_1_x86_temp_value_type=="Imm"&&expr_2_x86_temp_value_type!="Imm"){
      ss << "  ucomiss " << x86_temp_FPregister << ", " << TEMP_REG2;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
      updateRegisterAvailability(TEMP_REG2, true);
      LfpReg = x86_temp_FPregister;
      RfpReg = TEMP_REG2;
    }else if(expr_1_x86_temp_value_type!="Imm"&&expr_2_x86_temp_value_type=="Imm"){
      ss << "  ucomiss " << TEMP_REG1 << ", " << x86_temp_FPregister;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
      updateRegisterAvailability(TEMP_REG1, true);
      LfpReg = TEMP_REG1;
      RfpReg = x86_temp_FPregister;
    }else if(expr_1_x86_temp_value_type=="Imm"&&expr_2_x86_temp_value_type=="Imm"){
      ss << "  ucomiss " << FP_REG1 << ", " << FP_REG2;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
      LfpReg = FP_REG1;
      RfpReg = FP_REG2;
    }
    else{
      ss << "  ucomiss " << TEMP_REG1 << ", " << TEMP_REG2;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
      updateRegisterAvailability(TEMP_REG1, true);
      updateRegisterAvailability(TEMP_REG2, true);
      LfpReg = TEMP_REG1;
      RfpReg = TEMP_REG2;
    }

    
  }
 
  auto reg = checkBoolRegisterAvailability();
  switch (local_op)
  {
  case eLT:
    
    temp_op = eLT;
    if(temp_type == INT || temp_type ==BOOL)
      x86_function_map[globalContext.currentFrameName].push_back("  setl " + reg);
    else
      x86_function_map[globalContext.currentFrameName].push_back("  setb " + reg);
    
    break;
  case eLE: 

    temp_op = eLE;
    if(temp_type == INT || temp_type ==BOOL)
      x86_function_map[globalContext.currentFrameName].push_back("  setle " + reg);
    else
      x86_function_map[globalContext.currentFrameName].push_back("  setbe " + reg);
    
    break;
  case eGT:
    
    
    temp_op = eGT;
    if(temp_type == INT || temp_type ==BOOL)
      x86_function_map[globalContext.currentFrameName].push_back("  setg "+ reg);
    else
      x86_function_map[globalContext.currentFrameName].push_back("  seta "+ reg);
    break;
  case eGE:
 
    temp_op = eGE;
    if(temp_type == INT || temp_type ==BOOL)
      x86_function_map[globalContext.currentFrameName].push_back("  setge " + reg);
    else
      x86_function_map[globalContext.currentFrameName].push_back("  setae " + reg);
    break;
  case eEQ:
    
    if(temp_type == INT || temp_type == BOOL)
    {
          x86_function_map[globalContext.currentFrameName].push_back("  sete " + reg);
    }
    else
    {
          x86_function_map[globalContext.currentFrameName].push_back("  subss " + LfpReg + ", " + RfpReg);
          x86_function_map[globalContext.currentFrameName].push_back("  ucomiss " + LfpReg + ", dword [epsilon]");
          x86_function_map[globalContext.currentFrameName].push_back("  setbe " + reg);
    }
    temp_op = eEQ;
   
    break;
  case eNE:

    temp_op = eNE;
    x86_function_map[globalContext.currentFrameName].push_back("  setne " + reg);
    break;
  default:
    ERRPR_HANDLE("unknown EREL operation")
    break;
  }
  auto INTreg = checkIntRegisterAvailability();
  updateRegisterAvailability(INTreg, false);
  x86_function_map[globalContext.currentFrameName].push_back("  movzx " + INTreg + ", " + reg);
  updateRegisterAvailability(reg, true);
  x86_temp_value_type ="Var";
  temp_type = BOOL;
  
  TEMP_REG = INTreg;
}

void JLCX86Generator::visitEAnd(EAnd *e_and)
{
  /* Code For EAnd Goes Here */
  updateRegisterAvailability("eax", false);//except fixed reg usage, dont allocate eax
  auto current_block = LLVM_builder_->GetInsertBlock();
  auto parent = current_block->getParent();
  auto and_true_block = llvm::BasicBlock::Create(*LLVM_Context_, "and.true", parent);
  auto and_end_block = llvm::BasicBlock::Create(*LLVM_Context_, "and.end", parent);
  ASTcounter++;
  auto temp = ASTcounter;
  if(ASTcounter==1){
    updateBoolBlk();
  }
  if (e_and->expr_1) e_and->expr_1->accept(this);

  auto TEMP_REG1=TEMP_REG;

  if(x86_temp_value_type=="Imm"){
    std::stringstream ss;
    auto reg = checkIntRegisterAvailability();
    ss << "  mov " << reg << ", " << x86_temp_value<<std::endl;
    ss << "  cmp "<<reg<<", 0"<<std::endl;
    TEMP_REG1 = reg;
    ss << "  je " << BoolBlkLabel;
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  } else{
    std::stringstream ss;
    ss << "  cmp " << TEMP_REG1 << ", 0"<<std::endl;
    ss << "  je " << BoolBlkLabel;
    updateRegisterAvailability(TEMP_REG1, true);
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }
 
  
  if (e_and->expr_2) e_and->expr_2->accept(this);
  
  auto expr_2_llvm_value = llvm_temp_value_;
  auto TEMP_REG2=TEMP_REG;
  if(temp==1){
    if(x86_temp_value_type=="Imm"){
      std::stringstream ss;
      auto reg = checkIntRegisterAvailability();
      ss << "  mov " << reg << ", " << x86_temp_value<<std::endl;
      TEMP_REG2 = reg;
      ss << "  jmp " << BoolBlkEndLabel << std::endl;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
      
    } else{
      std::stringstream ss;
      ss << "  jmp " << BoolBlkEndLabel << std::endl;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    }
  }else{
    if(x86_temp_value_type=="Imm"){
      std::stringstream ss;
      auto reg = checkIntRegisterAvailability();
      ss << "  mov " << reg << ", " << x86_temp_value<<std::endl;
      ss << "  cmp "<<reg<<", 0"<<std::endl;
      ss << "  je " << BoolBlkLabel;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    }else{
      std::stringstream ss;
      ss << "  cmp " << TEMP_REG2 << ", 0"<<std::endl;
      ss << "  je " << BoolBlkLabel;
      updateRegisterAvailability(TEMP_REG2, true);
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    }
  }


  if(temp==1){
    std::stringstream ss1;
    x86_function_map[globalContext.currentFrameName].push_back(BoolBlkLabel+":");
    ss1 << "  and " << TEMP_REG1 << ", 0" << std::endl;
    ss1 << "  jmp " << BoolBlkEndEndLabel << std::endl;
    x86_function_map[globalContext.currentFrameName].push_back(ss1.str());
    x86_function_map[globalContext.currentFrameName].push_back(BoolBlkEndLabel+":");
    std::stringstream ss2;
    ss2<< "  and " << TEMP_REG1 << ", " << TEMP_REG2 << std::endl;
    x86_function_map[globalContext.currentFrameName].push_back(ss2.str());

    x86_function_map[globalContext.currentFrameName].push_back(BoolBlkEndEndLabel+":");
    TEMP_REG =TEMP_REG1;
    updateRegisterAvailability(TEMP_REG2, true);
    updateRegisterAvailability(TEMP_REG, false);
    ASTcounter = 0;
  }
    
  

  x86_temp_value_type = "Var";
  temp_type = BOOL;

}

void JLCX86Generator::visitEOr(EOr *e_or)
{
  /* Code For EOr Goes Here */
  updateRegisterAvailability("eax", false);//except fixed reg usage, dont allocate eax
  auto current_block = LLVM_builder_->GetInsertBlock();
  auto parent = current_block->getParent();
  auto or_false_block = llvm::BasicBlock::Create(*LLVM_Context_, "or.false", parent);
  auto or_end_block = llvm::BasicBlock::Create(*LLVM_Context_, "or.end", parent);
  ASTcounter++;
  auto temp = ASTcounter;
  if(ASTcounter==1){
    updateBoolBlk();
  }
  if (e_or->expr_1) e_or->expr_1->accept(this);

  auto TEMP_REG1=TEMP_REG;

  
  if(x86_temp_value_type=="Imm"){
     std::stringstream ss;
    auto reg = checkIntRegisterAvailability();
    ss << "  mov " << reg << ", " << x86_temp_value<<std::endl;
    ss << "  cmp "<<reg<<", 1"<<std::endl;
    ss << "  je " << BoolBlkLabel;
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  } else{
     std::stringstream ss;
    ss << "  cmp " << TEMP_REG1 << ", 1"<<std::endl;
    ss << "  je " << BoolBlkLabel << std::endl;
    updateRegisterAvailability(TEMP_REG1, true);
    x86_function_map[globalContext.currentFrameName].push_back(ss.str());
  }
 
  if (e_or->expr_2) e_or->expr_2->accept(this);
  auto expr_2_llvm_value = llvm_temp_value_;
  auto TEMP_REG2=TEMP_REG;

  if(temp==1){
    if(x86_temp_value_type=="Imm"){
      std::stringstream ss;
      auto reg = checkIntRegisterAvailability();
      ss << "  mov " << reg << ", " << x86_temp_value<<std::endl;
      ss << "  jmp " << BoolBlkEndLabel;
      TEMP_REG2 = reg;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    } else{
      std::stringstream ss;
      ss << "  jmp " << BoolBlkEndLabel << std::endl;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    }
  }else{
    if(x86_temp_value_type=="Imm"){
      std::stringstream ss;
      auto reg = checkIntRegisterAvailability();
      ss << "  mov " << reg << ", " << x86_temp_value<<std::endl;
      ss << "  cmp "<<reg<<", 1"<<std::endl;
      ss << "  je " << BoolBlkLabel;
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    }else{
      std::stringstream ss;
      ss << "  cmp " << TEMP_REG2 << ", 1"<<std::endl;
      ss << "  je " << BoolBlkLabel;
      updateRegisterAvailability(TEMP_REG2, true);
      x86_function_map[globalContext.currentFrameName].push_back(ss.str());
    }
  }
  
  
  if(temp==1){
    std::stringstream ss1;
    x86_function_map[globalContext.currentFrameName].push_back(BoolBlkLabel+":");
    ss1 << "  or " << TEMP_REG1 << ", 1" << std::endl;
    ss1 << "  jmp " << BoolBlkEndEndLabel << std::endl;
    x86_function_map[globalContext.currentFrameName].push_back(ss1.str());
    x86_function_map[globalContext.currentFrameName].push_back(BoolBlkEndLabel+":");
    std::stringstream ss2;
    ss2<< "  or " << TEMP_REG1 << ", " << TEMP_REG2 << std::endl;
    x86_function_map[globalContext.currentFrameName].push_back(ss2.str());
    x86_function_map[globalContext.currentFrameName].push_back(BoolBlkEndEndLabel+":");
    TEMP_REG =TEMP_REG1;
    updateRegisterAvailability(TEMP_REG2, true);
    updateRegisterAvailability(TEMP_REG, false);
    ASTcounter = 0;
  }
  
  
  
  x86_temp_value_type = "Var";
  temp_type = BOOL;
  
}


void JLCX86Generator::visitPlus(Plus *plus)
{
  /* Code For Plus Goes Here */
  temp_op = eADD;
}

void JLCX86Generator::visitMinus(Minus *minus)
{
  /* Code For Minus Goes Here */
  temp_op = eSUB;
}

void JLCX86Generator::visitTimes(Times *times)
{
  /* Code For Times Goes Here */
  temp_op = eMUL;
}

void JLCX86Generator::visitDiv(Div *div)
{
  /* Code For Div Goes Here */
  temp_op = eDIV;
}

void JLCX86Generator::visitMod(Mod *mod)
{
  /* Code For Mod Goes Here */
  temp_op = eMOD;
}

void JLCX86Generator::visitLTH(LTH *lth)
{
  /* Code For LTH Goes Here */
  temp_op = eLT;
}

void JLCX86Generator::visitLE(LE *le)
{
  /* Code For LE Goes Here */
  temp_op = eLE;
}

void JLCX86Generator::visitGTH(GTH *gth)
{
  /* Code For GTH Goes Here */
  temp_op = eGT;
}

void JLCX86Generator::visitGE(GE *ge)
{
  /* Code For GE Goes Here */
  temp_op = eGE;
}

void JLCX86Generator::visitEQU(EQU *equ)
{
  /* Code For EQU Goes Here */
  temp_op = eEQ;
}

void JLCX86Generator::visitNE(NE *ne)
{
  /* Code For NE Goes Here */
  temp_op = eNE;
}
