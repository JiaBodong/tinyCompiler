/* File generated by the BNF Converter (bnfc 2.9.4). */

#ifndef __JLC_LLVM_GENERATOR__
#define __JLC_LLVM_GENERATOR__
/* You might want to change the above name. */
#include <iostream>

#include "Absyn.H"
#include "context.H"

#include "Skeleton.H"

// llvm dependencies
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Value.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Type.h"

class JLCLLVMGenerator : public Skeleton
{
public:
  Context globalContext;
  type_enum temp_type;
  op_enum temp_op;

  JLCLLVMGenerator(): LLVM_Context_(std::make_unique<llvm::LLVMContext>()),
                      LLVM_module_(std::make_unique<llvm::Module>("JLC_llvm", *LLVM_Context_)),
                      LLVM_builder_(std::make_unique<llvm::IRBuilder<>>(*LLVM_Context_))
  {
    addExternalFunc();
  };

  ~JLCLLVMGenerator(){
    LLVM_module_->print(llvm::outs(), nullptr);
  };
  // std::vector<std::string> global_declear_segment;

private:
  /* serving for generating llvm code*/
  std::unique_ptr<llvm::LLVMContext> LLVM_Context_;
  std::unique_ptr<llvm::Module> LLVM_module_;
  std::unique_ptr<llvm::IRBuilder<>> LLVM_builder_;

  llvm::Value * llvm_temp_value_;

  // for saving the block of the value
  // @TODO: there are should be a better way to do this
  std::map<std::string,llvm::BasicBlock *> value_block_map_; 

  void setLLVMTempValue(llvm::Value * value){
    llvm_temp_value_ = value;
    // add the block of the value to the map
    value_block_map_[std::string(value->getName())] = LLVM_builder_->GetInsertBlock();
  }
  
  llvm::BasicBlock * getBlockOfValue(llvm::Value * & value){
    if (value_block_map_.find(std::string(value->getName())) != value_block_map_.end()){
      return value_block_map_[std::string(value->getName())];
    }
    // should not reach here
    std::cerr << "Error: block of value not found" << std::endl;
    exit(1);
    return nullptr;
  }

  // for saving the variable in the block, the last element is the current block
  // mapping from original variable name to llvm variable 
  std::vector<std::map<std::string, llvm::Value *>> block_var_map_list;

  void addBlockVarMap(){
    block_var_map_list.push_back(std::map<std::string, llvm::Value *>());
  }

  void removeBlockVarMap(){
    block_var_map_list.pop_back();
  }

  void addVarToBlockMap(std::string var_name, llvm::Value * var_value){
    block_var_map_list.back()[var_name] = var_value;
  }

  llvm::Value * getVarFromBlockMap(std::string var_name){
    for (int i = block_var_map_list.size() - 1; i >= 0; i--){
      if (block_var_map_list[i].find(var_name) != block_var_map_list[i].end()){
        return block_var_map_list[i][var_name];
      }
    }
    // it should not reach here
    std::cerr << "Error: variable " << var_name << " not found in llvm block name map" << std::endl;
    return nullptr;
  }

  // type conversion
  llvm::Type *convertType(type_enum type);
  // add inner/external function to the head of the ll file
  // for example, printInt, printDouble, printString, printBool
  void addExternalFunc();

  void addFuncDeclearation(Frame &frame);

public:
  // void visitProg(Prog *p);
  // void visitTopDef(TopDef *p);
  // void visitArg(Arg *p);
  // void visitBlk(Blk *p);
  // void visitStmt(Stmt *p);
  // void visitItem(Item *p);
  // void visitType(Type *p);
  // void visitExpr(Expr *p);
  // void visitAddOp(AddOp *p);
  // void visitMulOp(MulOp *p);
  // void visitRelOp(RelOp *p);
  
  void visitProgram(Program *p);
  void visitFnDef(FnDef *p);
  void visitArgument(Argument *p);
  void visitBlock(Block *p);
  void visitEmpty(Empty *p);
  void visitBStmt(BStmt *p);
  void visitDecl(Decl *p);
  void visitNoInit(NoInit *p);
  void visitInit(Init *p);
  void visitAss(Ass *p);
  void visitIncr(Incr *p);
  void visitDecr(Decr *p);
  void visitRet(Ret *p);
  void visitVRet(VRet *p);
  void visitCond(Cond *p);
  void visitCondElse(CondElse *p);
  void visitWhile(While *p);
  void visitSExp(SExp *p);
  void visitInt(Int *p);
  void visitDoub(Doub *p);
  void visitBool(Bool *p);
  void visitVoid(Void *p);
  void visitFun(Fun *p);
  void visitEVar(EVar *p);
  void visitELitInt(ELitInt *p);
  void visitELitDoub(ELitDoub *p);
  void visitELitTrue(ELitTrue *p);
  void visitELitFalse(ELitFalse *p);
  void visitEApp(EApp *p);
  void visitEString(EString *p);
  void visitNeg(Neg *p);
  void visitNot(Not *p);
  void visitEMul(EMul *p);
  void visitEAdd(EAdd *p);
  void visitERel(ERel *p);
  void visitEAnd(EAnd *p);
  void visitEOr(EOr *p);
  void visitPlus(Plus *p);
  void visitMinus(Minus *p);
  void visitTimes(Times *p);
  void visitDiv(Div *p);
  void visitMod(Mod *p);
  void visitLTH(LTH *p);
  void visitLE(LE *p);
  void visitGTH(GTH *p);
  void visitGE(GE *p);
  void visitEQU(EQU *p);
  void visitNE(NE *p);
  // void visitListTopDef(ListTopDef *p);
  // void visitListArg(ListArg *p);
  // void visitListStmt(ListStmt *p);
  // void visitListItem(ListItem *p);
  // void visitListType(ListType *p);
  // void visitListExpr(ListExpr *p);

  // void visitInteger(Integer x);
  // void visitChar(Char x);
  // void visitDouble(Double x);
  // void visitString(String x);
  // void visitIdent(Ident x);

};


#endif
